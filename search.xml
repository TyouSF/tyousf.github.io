<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Locust性能测试初探]]></title>
    <url>%2FLocust%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[An open source load testing tool. Define user behaviour with Python code, and swarm your system with millions of simultaneous users. –Locust 前述 到目前为止，对于性能测试的实践其实也并不是很多。为了弥补这片空白，也是各种找资料学习。网上关于性能测试资料最多的，其实大家一搜索便知道一二，其中： loadrunner Jmeter 这两款工具也是目前能够检索到相关资料较多的测试工具，这两者的区别也很明显： loadrunner 是一款商用软件，需要收费，相比之下，Jmeter 则是开源免费的 二者的并发机制有所不同，想更深入的同学可自行了解，此处不多述 性能测试引用百度的介绍———— 性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。负载测试和压力测试都属于性能测试，两者可以结合进行。通过负载测试，确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况。压力测试是通过确定一个系统的瓶颈或者不能接受的性能点，来获得系统能提供的最大服务级别的测试。 Locust的发现由于自己也想更多的弥补这方面的空白，因为在调查性能测试工具的过程中，无意间发现了 Locust 这样一个开源的框架，进一步仔细看后，发现 Locust 使用的是 python 语言编程实现的，恰巧本小白现在也刚好正在主要使用 python，因此二话不说，就学起来，重点是：Locust 也是免费开源的啊，而且目前国内对其的了解和使用也相对较少，说不定以后小白就走在了国内的前沿了呢，有木有很厉害，那就赶紧跟我一起学起来吧！！！ Locust 初探 以下内容其实也纯属搬砖，为什么这么说呢，因为这些都源自官方文档，没有耐心看英文，想要快速一睹 Locust 真面目的不妨就来看看，让我们快速窥探 Locust 吧。 Locust 安装整个安装和检测等，都是在 python shell 下完成的： 在 python shell 命令下，使用 pip 完成快速安装： 1pip install locustio 安装完成后，检测是否安装成功： 1locust --help 如果你想使用 locust 更为强大的分布式性能测试，那么还需要安装 pyzmq 1pip install pyzmq 注意事项操作系统不同，安装的方式有所不同，并且安装后可能都会遇到一些问题，请详细查看下方内容，减少走弯路。 当前版本的问题 ModuleNotFoundError: No module named &#39;core&#39; 的错误 当前情况下，无论是在 windows，还是 linux/macos，在当前的 locust 版本下，安装后，可能存在无法使用的问题，这个问题是在使用 locust --help 会提示 ModuleNotFoundError: No module named &#39;core&#39; 的错误，这种问题是当前 locust 的一个 bug， 在 locust git项目中，可以查到相应的解决方案，遇到此问题，解决方式是： pip uninstall locustio 先卸载安装的 locust pip install locustio==0.8a2 使用新的安装命令安装 locust -f locustfile.py 再次检测，会发现，已经解决了问题 ✌ Windows 平台下安装的问题 从官方文档中，很清楚的提及操作系统的问题，官方推荐是建议在 Linux/Mac OS 上使用，其中原因是对于操作系统内核的使用兼容上。因此，在 Win 平台下安装，会遇到安装失败的问题，通常是需要安装 Visual C++ 的。因此安装前请确认 Visual C++各系列是或否都已经安装。 如果不确定，那么久按照失败的提示，访问 Visual C++ 官网 Visual C++ 下载安装 安装后再使用上述安装命令就可以发现，安装OK ✌ 了 Locust 快速示例根据官方文档，快速示例有两种写法，区别是在于对于用户行为定义的两种不同形式，一种是采用 tasks 参数，指定用户行为；一种是采用 @task 装饰器，在用户行为类内部定义。 第一种，单独定义行为函数，采用 tasks 123456789101112131415161718192021from locust import HttpLocust, TaskSetdef login(l): l.client.post(&quot;/login&quot;, &#123;&quot;username&quot;:&quot;ellen_key&quot;, &quot;password&quot;:&quot;education&quot;&#125;)def index(l): l.client.get(&quot;/&quot;)def profile(l): l.client.get(&quot;/profile&quot;)class UserBehavior(TaskSet): tasks = &#123;index: 2, profile: 1&#125; def on_start(self): login(self)class WebsiteUser(HttpLocust): task_set = UserBehavior min_wait = 5000 max_wait = 9000 行为类内部，采用 @task 装饰器定义 12345678910111213141516171819202122from locust import HttpLocust, TaskSet, taskclass UserBehavior(TaskSet): def on_start(self): &quot;&quot;&quot; on_start is called when a Locust start before any task is scheduled &quot;&quot;&quot; self.login() def login(self): self.client.post(&quot;/login&quot;, &#123;&quot;username&quot;:&quot;ellen_key&quot;, &quot;password&quot;:&quot;education&quot;&#125;) @task(2) def index(self): self.client.get(&quot;/&quot;) @task(1) def profile(self): self.client.get(&quot;/profile&quot;)class WebsiteUser(HttpLocust): task_set = UserBehavior min_wait = 5000 max_wait = 9000 二者无论采用哪种，都是一样的，但是官方推荐使用的是 @task 装饰器的形式。 启动运行如果上述脚本的名称为 “locustfile.py” 那么我们便可以直接运行如下命令，启动脚本：1locust --host=http://example.com 如果脚本名称不是 locust 默认支持的，那么运行的时候也需要指定脚本文件：1locust -f locust_files/my_locust_file.py --host=http://example.com 访问 locust 网页成功启动可以到如下的命令提示：12Starting web monitor at *:8089Starting Locust 0.8a2 通过如下地址即可访问：1http://localhost:8089/ 打开 locust 实时监控的页面后，我们首先需要操作的便是配置： 并发用户数 产生模拟用户的速度 配置后，即可进入实时监控页面，看到各个响应的性能指标等 结语 相信通过上述的内容，小伙伴们都已经掌握了基本的 locust 的使用，接下来的内容中我们将逐一介绍 locust 中各个属性以及类的的特性和使用。 让我们一起共勉： 持续不断地学习，是更好的成长 —TyouSF 参考资料 Locust 官网Locust 官方文档Locust 其他参考Locust Git项目]]></content>
      <categories>
        <category>Locust</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>locust</tag>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git中多个sshKey的管理]]></title>
    <url>%2FGit%E4%B8%AD%E5%A4%9A%E4%B8%AAsshKey%E7%9A%84%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[在使用Git时，我们很多时候会遇到这样的问题 公司有一个 Git 仓库，我们需要持续的完成工作中所需要完成的任务并提交代码 个人自己平时做的一些小项目，写的小工具，在 Git 上托管，我们需要提交 …或者我们自己接了一些外包的项目，需要提交至外包项目的 Git 中 这个时候，如果邮箱都一样，那么自然不需要去管理多个 sshkey 。但是大多数的情况下，我们更期望或者实际工作中更为现实的是，每一个不同的项目，我们都会有不同的邮箱来管理和提交。 问题如何去管理多个 sshkey 呢？这也就是我们本文要解决的问题。 具体实操废话不多说，直接上操作： 根据官文，通常生成一个 sshkey 只需要 gitbash 中输入如下命令：1ssh-keygen 上述生成的是默认的 key 文件，在没有其他配置的情况下，通常所有的 git 仓库提交内容都会优先使用该命令生成的公钥，对应的文件名称是：“id_rsa” 与 “id_rsa.pub”。 因为我们需要为不同的 git 仓库来配置不同的 sshkey，因此我们在生成 sshkey 的时候，就不能够再使用上述的简化命令了。 第一步 为了简化我们的操作，我们可以使用更为完善的命令，如下↓：1ssh-keygen -t rsa -C &quot;yourmail@gmail.com&quot; -f ~/.ssh/sshname 例如，我们在公司使用的邮箱是 mycompany@mail.com ，我们期望公司使用的 sshkey 名为“mycompany”，那么我们的命令便是(其中，“mycompany” 文件名前的 ~/.ssh/ 是我们存放 sshkey 的路径也是默认 git 存放的路径)：1ssh-keygen -t rsa -C &quot;mycompany@mail.com&quot; -f ~/.ssh/mycompany 第二步 用同样的方法，我们可以继续为其他项目生成相应的 key，此处假设我们生成的第二个 key 的名称为：“mygit” 第三步 配置 config 文件–进入到 git 中存放 sshkey 的目录下，即 ~/.ssh/ 目录下，创建一个 config 文件。 创建 tips： 在windows下新建一个txt文本，然后将名字后缀一起改成config即可 在bash下的话直接touch config 即可 假设公司的 git 地址是：code.company.io自己在 github 的项目地址是：github.com并且假设我们公司的用户名叫：companynick自己在 github 的用户名是：mynick 那么添加的内容如下↓：12345678910111213# gitcompany // 新 host 的称呼 Host code.company.io // 主机名字，不能重名 HostName code.company.io // 主机所在域名或IP PreferredAuthentications publickey IdentityFile ~/.ssh/mycompany // 私钥路径 User companynick // 用户名称# github Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/mygit User mynick 第四步 在公司的 git 以及自己的 github 中添加各自对应的公钥。 第五步 测试连接是否成功，成功则证明我们的配置已经完成了，就可以在以后提交的时候使用不同的配置。测试连接命令：1ssh -T git@github.com 测试连接地址 tips可以在仓库克隆的地址中得到。 最后，有关全局配置的说明： 取消全局配置信息–12git config --global --unset user.namegit config --global --unset user.email 单个 git 仓库下配置特定的 username 与 email–12git config user.name &quot;yourname&quot;git config user.email &quot;youremail&quot; 让我们一起共勉： 持续不断地学习，是更好的成长 —TyouSF 参考资料 Pro Git 简体中文版Git 简易指南Git 实操学习站点]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles 简明实用教程]]></title>
    <url>%2FCharles-%E7%AE%80%E6%98%8E%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Charles是一个HTTP代理服务器，HTTP监视器，反转代理服务器。它允许一个开发者查看所有连接互联网的HTTP通信，这些包括request, response和HTTP headers （包含cookies与caching信息）。 百度百科 Charles 简述Charles 是一款非常强大的 HTTP 调试工具，并且兼容几乎所有的平台，可以让开发人员以及测试人员借此来查看到所有设备与服务器之间的 HTTP 以及 SSL/HTTPS 数据交换过程。 然而对于国内的使用者来说，美中不足的是：charles 虽然功能强大，但是却是收费的！ 不过这对于我们来说并不是难事，总有办法解决的，你说不是吗？！ Charles 主要的功能包括： 截取 Http 和 Https 网络封包。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 支持模拟慢速网络。 安装截至本文发布时，当前 Charles 官网最新版本是4.1.2，相信细心的你在篇头的截图中已经观察到了。 下载地址Charles 下载 在下载页面，可根据自己实际的情况下载对应的版本。本教程将不赘述破解过程，主讲解一些实际使用过程中常用的一些技巧，因此当前即使不破解，使用试用也是可以完成相关的操作的。 安装过程相信你已经是当今冲锋在互联网浪头的老司机了，这样的基础安装相信已经可以不用多说了，根据自己的需要，一路下一步的安装走起吧。 界面charles抓包的显示，支持两种模式，Structure和Sequence。 Structure形式如下图 优点：可以很清晰的看到请求的数据结构，而且是以域名划分请求信息的，可以很清晰的去分析和处理数据。 Sequence形式如下图 优点：可以看到全部请求，这里的结果以数据请求的顺序来显示，最新的请求显示在最下面。 structure 适合对单一系列的访问请求从宏观上进行把握，可以快速定位。sequence 适合精确定位内容，因为每条sequence 都有size，status等属性信息，方便快速定位这条结果的价值。笔者在实际使用过程中由于经常要查看相应的数据，并且也知道具体的访问请求，因此常用 structure 结果，大家可以根据实际情况进行具体切换即可。 PC端的使用charles会自动配置浏览器和工具的代理设置，所以说打开工具直接就已经是抓包状态了。 当我们安装完毕启动 charles 时，charles 会进行一些初始化的设定，这个设定我们可以自行在 charles 中根据实际需要来更改，初始的设定下，启动 Charles 后，此时便已经默认监视了 PC 端所有网络数据传输的情况。不信你可以打开 charles 后，使用浏览器访问一些网页，此时这些网页的访问便出现在了 charles 的窗口内。 移动端使用想要抓取移动端应用的接口访问情况，使用 Charles 进行一些简单的设定即可。 一下便是设定的步骤： 前提：手机和我们使用 charles 的 PC 应当处于同一个局域网内，这是最基本的要求了。即：手机所连接的热点与电脑所连接的路由是同一个即可； 进入 charles 的代理设定选项中，允许代理，并设定端口号（一般默认8888），如下图： 使用 PC 的 cmd 查看本机当前的 ip 地址，然后在手机端的 wifi 代理设置那里去进行相关的配置设置，类似下图：服务器填写 PC 端 ip 地址，端口填写操作2中所设定的代理端口号即可； 手机设定好，连接成功后，charles 页面便会出现一个是否抓取的相关确认弹窗，我们直接选择允许即可，此时使用手机进行的相关访问数据便可以被监听到了。 小提示：为了更方便的查看手机端的抓包情况，可以关闭掉 PC 上的监听。 技巧过滤网络请求通常情况下，我们需要对网络请求进行过滤，只监控向指定目录服务器上发送的请求。 方法—— 在主界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：http://yourserver.com , 那么只需要在 Filter 栏中填入 yourserver 即可。 在 Charles 的菜单栏选择 “Proxy”-&gt;”Recording Settings” 中选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。如下图： 在想过滤的网络请求上右击，选择 “Focus”，可以临时性的，快速地过滤出一些没有通过关键字的一类网络请求。 截取 Https 通讯信息通常情况下，如果是测试环境，为了方便测试，多数情况下是没有加密的网络通信，使用 Charles 可以直接抓取到相关的通讯信息，但是正式环境就不行了，没有相关的证书我们也只是能看到访问的地址，而交互的数据等我们是无法查看的。 如果你需要截取分析 Https 协议相关的内容。那么需要安装 Charles 的 CA 证书。具体步骤如下： 点击 Charles 的顶部菜单，选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate” 进行证书安装： Charles 默认也并不截取 Https 网络通讯的信息，如果你想对截取某个网站上的所有 Https 网络请求，可以在该请求上右击，选择 enable SSL proxy，如下图所示： 截取移动设备中的 Https 通讯信息如果我们需要在 iOS 或 Android 机器上截取 Https 协议的通讯内容，还需要在手机上安装相应的证书。 点击 Charles 的顶部菜单，选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate on a Mobile Device or Remote Browser” 在设备上设置好 Charles 为代理后，在手机浏览器中访问地址：http://charlesproxy.com/getssl ，即可打开证书安装的界面，安装完证书后，就可以截取手机上的 Https 通讯内容了。 注意：默认情况下 Charles 并不做截取，你还需要在要截取的网络请求上右击，选择 SSL proxy 菜单项。 模拟慢速网络在测试过程中，我们也通常会模拟用户真实的 3G， 4G 甚至是 2G 的网络环境下我们应用的真实反馈情况等等，Charles 对此需求提供了很好的支持。 在 Charles 的菜单上，选择 “Proxy”-&gt;“Throttle Setting” 项，在之后弹出的对话框中，我们可以勾选上 “Enable Throttling”，并且可以设置 Throttle Preset 的类型。如下图所示： 小提示：如果我们只想模拟指定网站的慢速网络，可以再勾选上图中的 “Only for selected hosts” 项，然后在对话框的下半部分设置中增加指定的 hosts 项即可。 修改网络请求内容有些时候为了调试服务器的接口，我们需要反复尝试不同参数的网络请求。Charles 可以方便地提供网络请求的修改和重发功能。 对于以往的网络请求上点击右键，选择 “Compose”，即可创建一个可编辑的网络请求。如下所示： 新建一个自定义的请求，可以在 “Tools”-&gt;“Compose a new request” 或中进行设置： 有了请求后，们可以修改该请求的任何信息，包括 URL 地址、端口、参数等，之后点击 “Execute” 即可发送该修改后的网络请求。 Charles 支持我们多次修改和发送该请求，这对于我们和服务器端调试接口非常方便。 给服务器做压力测试我们可以使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力，方法如下。我们在想打压的网络请求上（POST 或 GET 请求均可）右击，然后选择 「Repeat Advanced」菜单项，如下所示： 接着我们就可以在弹出的对话框中，选择打压的并发线程数以及打压次数，确定之后，即可开始打压。 修改服务器返回内容有些时候我们想让服务器返回一些指定的内容，方便我们调试一些特殊情况。例如列表页面为空的情况，数据异常的情况，部分耗时的网络请求超时的情况等。如果没有 Charles，要服务器配合构造相应的数据显得会比较麻烦。这个时候，使用 Charles 相关的功能就可以满足我们的需求。 根据具体的需求，Charles 提供了 Map 功能、 Rewrite 功能以及 Breakpoints 功能，都可以达到修改服务器返回内容的目的。这三者在功能上的差异是： Map 功能适合长期地将某一些请求重定向到另一个网络地址或本地文件。 Rewrite 功能适合对网络请求进行一些正则替换。 Breakpoints 功能适合做一些临时性的修改。 Map 功能Charles 的 Map 功能分 Map Remote 和 Map Local 两种，顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。 在 Charles 的菜单中，选择 “Tools”-&gt;”Map Remote” 或 “Map Local” 即可进入到相应功能的设置页面。 对于 Map Remote 功能，我们需要分别填写网络重定向的源地址和目的地址，对于不需要限制的条件，可以留空。下图是一个示例，我将所有 testserver.com（测试服务器）的请求重定向到了 www.releaseserver.com（线上服务器）。 对于 Map Local 功能，我们需要填写的重定向的源地址和本地的目标文件。对于有一些复杂的网络请求结果，我们可以先使用 Charles 提供的 “Save Response…” 功能，将请求结果保存到本地（如下图所示），然后稍加修改，成为我们的目标映射文件。 下图是一个示例，我将一个指定的网络请求通过 Map Local 功能映射到了本地的一个经过修改的文件中。 Map Local 在使用的时候，有一个潜在的问题，就是其返回的 Http Response Header 与正常的请求并不一样。这个时候如果客户端校验了 Http Response Header 中的部分内容，就会使得该功能失效。解决办法是同时使用 Map Local 以下面提到的 Rewrite 功能，将相关的 Http 头 Rewrite 成我们希望的内容。 Rewrite 功能Rewrite 功能功能适合对某一类网络请求进行一些正则替换，以达到修改结果的目的。例如，我们的客户端有一个 API 请求是获得用户昵称，而我当前的昵称是 “tangqiaoboy”，如下所示： 我们想试着直接修改网络返回值，将 tangqiaoboy 换成成 iosboy。于是我们启用 Rewrite 功能，然后设置如下的规则： 完成设置之后，我们就可以从 Charles 中看到，之后的 API 获得的昵称被自动 Rewrite 成了 iosboy，如下图所示： Breakpoints 功能上面提供的 Rewrite 功能最适合做批量和长期的替换，但是很多时候，我们只是想临时修改一次网络请求结果，这个时候，使用 Rewrite 功能虽然也可以达到目的，但是过于麻烦，对于临时性的修改，我们最好使用 Breakpoints 功能。Breakpoints 功能类似代码调试时的断点一样，当指定的网络请求发生时，Charles 会截获该请求，这个时候，我们可以在 Charles 中临时修改网络请求的返回内容。下图是我们临时修改获取用户信息的 API，将用户的昵称进行了更改，修改完成后点击 “Execute” 则可以让网络请求继续进行。 注意点： 使用 Breakpoints 功能将网络请求截获并修改过程中，整个网络请求的计时并不会暂停，所以长时间的暂停可能导致客户端的请求超时。 结语关于 Charles 的简明实用教程，目前就先写这么多吧，希望在以后的实际使用过程中，大家通过不断的练习和使用，早日成为老司机。 让我们一起共勉： 持续不断地学习，是更好的成长 —TyouSF 参考资料 Charles 官网Charles 官网文档]]></content>
      <categories>
        <category>测试工具</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>Charles</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 类]]></title>
    <url>%2FPython3-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[–本篇主要讲述 Python中的对象：类– “优雅” “明确” “简单”Python 面向对象Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。本章节我们将详细介绍Python的面向对象编程。如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在头脑里头形成一个基本的面向对象的概念，这样有助于你更容易的学习Python的面向对象编程。接下来我们先来简单的了解下面向对象的一些基本特征。 类 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 实例变量：定义在方法中的变量，只作用于当前实例的类。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 方法：类中定义的函数。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。对象可以包含任意数量和类型的数据。 类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。 类对象类对象支持两种操作：属性引用和实例化。属性引用使用和 Python 中所有的属性引用一样的标准语法：obj.name。类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样: 12345678910class MyClass: &quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot; i = 12345 def f(self): return &apos;hello world&apos;# 实例化类x = MyClass()# 访问类的属性和方法print(&quot;MyClass 类的属性 i 为：&quot;, x.i)print(&quot;MyClass 类的方法 f 输出为：&quot;, x.f()) 以上创建了一个新的类实例并将该对象赋给局部变量 x，x 为空的对象。执行以上程序输出结果为： 12MyClass 类的属性 i 为： 12345MyClass 类的方法 f 输出为： hello world 很多类都倾向于将对象创建为有初始状态的。因此类可能会定义一个名为 init() 的特殊方法（构造方法），像下面这样： 12def __init__(self): self.data = [] 类定义了 init() 方法的话，类的实例化操作会自动调用 init() 方法。所以在下例中，可以这样创建一个新的实例: 1x = MyClass() 当然， init() 方法可以有参数，参数通过 init() 传递到类的实例化操作上。例如: 123456class Complex: def __init__(self, realpart, imagpart): self.r = realpart self.i = imagpartx = Complex(3.0, -4.5)print(x.r, x.i) // 输出结果：3.0 -4.5 self代表类的实例，而非类 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。 1234567class Test: def prt(self): print(self) print(self.__class__) t = Test()t.prt() 类的方法在类地内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例。 1234567891011121314151617#类定义class people: #定义基本属性 name = &apos;&apos; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))#实例化类p = people(&apos;runoob&apos;,10,30)p.speak() 继承1234567891011121314151617181920212223242526#类定义class people: #定义基本属性 name = &apos;&apos; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))#单继承示例class student(people): grade = &apos;&apos; def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))s = student(&apos;ken&apos;,10,60,3)s.speak() 多继承1234567891011121314151617181920212223242526272829303132333435363738394041#类定义class people: #定义基本属性 name = &apos;&apos; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))#单继承示例class student(people): grade = &apos;&apos; def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))#另一个类，多重继承之前的准备class speaker(): topic = &apos;&apos; name = &apos;&apos; def __init__(self,n,t): self.name = n self.topic = t def speak(self): print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic))#多重继承class sample(speaker,student): a =&apos;&apos; def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t)test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)test.speak() #方法名同，默认调用的是在括号中排前地父类的方法 类的专有方法 __init__ : 构造函数，在生成对象时调用 __del__ : 析构函数，释放对象时使用 __repr__ : 打印，转换 __setitem__ : 按照索引赋值 __getitem__ : 按照索引获取值 __len__ : 获得长度 __cmp__ : 比较运算 __call__ : 函数调用 __add__ : 加运算 __sub__ : 减运算 __mul__ : 乘运算 __div__ : 除运算 __mod__ : 求余运算 __pow__ : 乘方]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 函数]]></title>
    <url>%2FPython3-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[–本篇主要讲述 Python中的：函数– “优雅” “明确” “简单”Python Python 函数函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数能提高应用的模块性，和代码的重复利用率。在学习先前的数据类型时，我们也有讲解到很多的内置方法和函数。现在你也可以自己创建函数，这被叫做用户自定义函数。 定义你可以定义一个由自己想要功能的函数，以下是简单的规则： 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 函数内容以冒号起始，并且缩进。 return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。 一个简单的示例，就像这样：12345&gt;&gt;&gt; def hello():... print(&quot;hello function&quot;)...&gt;&gt;&gt; hello()hello function 调用Python内置了很多有用的函数，我们可以直接调用。要调用一个函数，需要知道函数的名称和参数。定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。如下实例调用了 printme() 函数：123456789# 定义函数def printme( str ): &quot;打印任何传入的字符串&quot; print (str); return; # 调用函数printme(&quot;我要调用用户自定义函数!&quot;);printme(&quot;再次调用同一函数&quot;); 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名” 参数传递在讲述具体参数的类型前，我们要明白一些比较重要的： 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响 python 传不可变对象实例12345678#!/usr/bin/python3 def ChangeInt( a ): a = 10b = 2ChangeInt(b)print( b ) # 结果是 2 实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。 传可变对象实例可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：12345678910111213#!/usr/bin/python3 # 可写函数说明def changeme( mylist ): &quot;修改传入的列表&quot; mylist.append([1,2,3,4]); print (&quot;函数内取值: &quot;, mylist) return # 调用changeme函数mylist = [10,20,30];changeme( mylist );print (&quot;函数外取值: &quot;, mylist) 传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下： 12函数内取值: [10, 20, 30, [1, 2, 3, 4]]函数外取值: [10, 20, 30, [1, 2, 3, 4]] 位置参数位置参数，必须以正确的顺序传入函数。调用时的数量必须和声明时的一样。调用printme()函数，你必须传入一个参数，不然会出现语法错误： 12345678910#!/usr/bin/python3 #可写函数说明def printme(a): &quot;打印任何传入的字符串&quot; print (a); return; #调用printme函数printme(); 以上实例输出结果： 1234Traceback (most recent call last): File &quot;test.py&quot;, line 10, in &lt;module&gt; printme();TypeError: printme() missing 1 required positional argument: &apos;a&apos; 以下实例中演示了函数参数的使用不需要使用指定顺序：1234567891011#!/usr/bin/python3 #可写函数说明def printinfo( name, age ): &quot;打印任何传入的字符串&quot; print (&quot;名字: &quot;, name); print (&quot;年龄: &quot;, age); return; #调用printinfo函数printinfo( age=50, name=&quot;runoob&quot; ); 输出结果： 12名字: runoob年龄: 50 默认参数调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值： 12345678910111213#!/usr/bin/python3 #可写函数说明def printinfo( name, age = 35 ): &quot;打印任何传入的字符串&quot; print (&quot;名字: &quot;, name); print (&quot;年龄: &quot;, age); return; #调用printinfo函数printinfo( age=50, name=&quot;runoob&quot; );print (&quot;------------------------&quot;)printinfo( name=&quot;runoob&quot; ); 输出结果： 12345名字: runoob年龄: 50------------------------名字: runoob年龄: 35 不定长参数可变参数在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。 我们以数学题为例子，给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……。要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下： 12345def calc(numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 但是调用的时候，需要先组装出一个list或tuple：1234&gt;&gt;&gt; calc([1, 2, 3])14&gt;&gt;&gt; calc((1, 3, 5, 7))84 如果利用可变参数，调用函数的方式可以简化成这样：1234&gt;&gt;&gt; calc(1, 2, 3)14&gt;&gt;&gt; calc(1, 3, 5, 7)84 所以，我们把函数的参数改为可变参数： 12345def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数： 1234&gt;&gt;&gt; calc(1, 2)5&gt;&gt;&gt; calc()0 如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做，在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：123&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(*nums)14 关键字参数可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例： 12def person(name, age, **kw): print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw) 函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数： 12&gt;&gt;&gt; person(&apos;Michael&apos;, 30)name: Michael age: 30 other: &#123;&#125; 也可以传入任意个数的关键字参数： 1234&gt;&gt;&gt; person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;)name: Bob age: 35 other: &#123;&apos;city&apos;: &apos;Beijing&apos;&#125;&gt;&gt;&gt; person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;)name: Adam age: 45 other: &#123;&apos;gender&apos;: &apos;M&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125; 关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。 和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去： 123&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;&gt;&gt;&gt; person(&apos;Jack&apos;, 24, city=extra[&apos;city&apos;], job=extra[&apos;job&apos;])name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125; 当然，上面复杂的调用可以用简化的写法： 123&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;&gt;&gt;&gt; person(&apos;Jack&apos;, 24, **extra)name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125; 最后Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！ 要注意定义可变参数和关键字参数的语法： *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 bool]]></title>
    <url>%2FPython3-bool%2F</url>
    <content type="text"><![CDATA[–本篇主要讲述 Python数据类型之：布尔型– “优雅” “明确” “简单”Python 有关布尔型其实相信大家并不陌生，因为这一点我们在上学期间的数学教材中就提到过真与假的相关概念。 在Python中，布尔型的真与假： True 表示真 False 表示假 请注意大小写，这与很多的编程语言中的写法是有一定区别的，请勿混淆。 Python中的布尔其实关于布尔型的数据，在此并没有太多要说的。 但是我依然相信大多数的初学者对于Python中的 bool 型数据掌握仅仅停留在两个单词 True 和False。 下面我们就来看看一些也许你还并不知道的 bool 型数据。 在 Python 内部，True 和 False 是 bool 的实例，实际上仅仅是内置的整数类型int的子类（以面向对象的观点来看）。 你能够将Ture和False看作是预定义的设置为整数1和整数0的变量。 下面让我们看看在交互式环境中实际的验证：1234567&gt;&gt;&gt; t = True&gt;&gt;&gt; n = 1&gt;&gt;&gt; t + 12&gt;&gt;&gt; f = False&gt;&gt;&gt; n * f0 在上述示例中，我们通过简单的运算可以看到，True 和 False 是可以直接与数字进行运算，并且其值也分别是对应的1和0（从上述例子看起来是这样，其实也确实是这样的，下面让我们更准确的验证：）1234&gt;&gt;&gt; True == 1True&gt;&gt;&gt; False == 0True 我们试图通过Python内部的字面值判断来尝试 True == 1 与 False == 0 可以看到其结果都得到了True，因此也可以印证 True 与 False 分别对应着 1 和 0。 更多关于Bool型，可在 Python 交互式环境下，使用：help(bool) 进行查看，或查阅官方文档：Python 官方文档。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 集合]]></title>
    <url>%2FPython3-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[–本篇主要讲述 Python数据类型之：集合– “优雅” “明确” “简单”Python Python中的数据类型：集合(set)。在Python中，集合数据类型英文称作：“ set ”。集合是各种数据的一个集合，在Python中的定义则是: 使用集合类 set() 来创建，set 接收一个可迭代对象作为参数; 12345678910&gt;&gt;&gt; s = set((&quot;a&quot;,1,2,&quot;b&quot;))&gt;&gt;&gt; s&#123;1, &apos;a&apos;, 2, &apos;b&apos;&#125;&gt;&gt;&gt; type(s)&lt;class &apos;set&apos;&gt;&gt;&gt;&gt; s = set(&quot;abc&quot;)&gt;&gt;&gt; s&#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;&#125;&gt;&gt;&gt; type(s)&lt;class &apos;set&apos;&gt; 使用花括号 { } 来创建； 12345&gt;&gt;&gt; s=&#123;1,2,3,4&#125;&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; type(s)&lt;class &apos;set&apos;&gt; 值得注意的是：如果是创建一个空的集合，那么将只能够使用 set() 进行创建！如果是创建一个空的集合，那么将只能够使用 set() 进行创建！如果是创建一个空的集合，那么将只能够使用 set() 进行创建！为什么？因为单独使用花括号 { }构建时，我们构建的是空的字典表！让我们看一看验证结果：123456&gt;&gt;&gt; d = &#123;&#125;&gt;&gt;&gt; type(d)&lt;class &apos;dict&apos;&gt;&gt;&gt;&gt; s = set()&gt;&gt;&gt; type(s)&lt;class &apos;set&apos;&gt; 相关的方法等示例展示，均以Python的交互式环境演示为主！ 集合数据类型的特性 集合是一个无序的，不重复的数据组合； 可进行关系测试，测试两组数据之前的交集、差集、并集等关系； 由于无序，因此集合不支持索引、切片等操作； 关系运算 + 加法操作在集合类型中是不被支持的！ - 两集合的差集（减数集合中有，但是在被减数集合中没有的数据） 1234&gt;&gt;&gt; s = &#123;1,2,3&#125;&gt;&gt;&gt; q = &#123;2,3,4&#125;&gt;&gt;&gt; s - q&#123;1&#125; | 两集合之间的并集（其结果自然也是去重后的结果） 12345678&gt;&gt;&gt; s = &#123;1,2,3&#125;&gt;&gt;&gt; q = &#123;4,5,6&#125;&gt;&gt;&gt; s | q&#123;1, 2, 3, 4, 5, 6&#125;&gt;&gt;&gt; s = &#123;1,2,3&#125;&gt;&gt;&gt; q = &#123;2,3,4&#125;&gt;&gt;&gt; s | q&#123;1, 2, 3, 4&#125; &amp; 两集合之间的交集 12345678&gt;&gt;&gt; s = &#123;1,2,3&#125;&gt;&gt;&gt; q = &#123;4,5,6&#125;&gt;&gt;&gt; s &amp; qset()&gt;&gt;&gt; s = &#123;1,2,3&#125;&gt;&gt;&gt; q = &#123;2,3,4&#125;&gt;&gt;&gt; s &amp; q&#123;2, 3&#125; ^ 两集合的对称差集（结果数据在两集合中不同时存在） 12345678&gt;&gt;&gt; s = &#123;1,2,3&#125;&gt;&gt;&gt; q = &#123;4,5,6&#125;&gt;&gt;&gt; s ^ q&#123;1, 2, 3, 4, 5, 6&#125;&gt;&gt;&gt; s = &#123;1,2,3&#125;&gt;&gt;&gt; q = &#123;2,3,4&#125;&gt;&gt;&gt; s ^ q&#123;1, 4&#125; in 成员运算符 - 判断指定元素是否存在于集合内，存在则为 True， 反之为 False 12345&gt;&gt;&gt; s = &#123;1,2,3&#125;&gt;&gt;&gt; 1 in sTrue&gt;&gt;&gt; 4 in sFalse not in 成员运算符 - 判断指定元素是否存在于集合内，不存在则为 True， 反之为 False 12345&gt;&gt;&gt; s = &#123;1,2,3&#125;&gt;&gt;&gt; 1 not in sFalse&gt;&gt;&gt; 4 not in sTrue 集合数据类型的常见内建函数 add( ) 向集合内添加单个元素，如果存在则不起作用 123456789&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; s.add((5,6))&gt;&gt;&gt; s&#123;1, 2, 3, 4, (5, 6)&#125;&gt;&gt;&gt; s.add(&quot;abc&quot;)&gt;&gt;&gt; s&#123;1, 2, 3, 4, (5, 6), &apos;abc&apos;&#125; clear( ) 清空集合 123456&gt;&gt;&gt; s = &#123;1, 2, 3&#125;&gt;&gt;&gt; s&#123;1, 2, 3&#125;&gt;&gt;&gt; s.clear()&gt;&gt;&gt; sset() copy( ) 创建集合的副本 1234&gt;&gt;&gt; s = &#123;1, 2, 3&#125;&gt;&gt;&gt; q = s.copy()&gt;&gt;&gt; q&#123;1, 2, 3&#125; difference( ) 差集（当前集合有而其他集合没有的差集） 123456&gt;&gt;&gt; s = &#123;1, 2, 3&#125;&gt;&gt;&gt; q = &#123;2, 3&#125;&gt;&gt;&gt; s.difference(q)&#123;1&#125;&gt;&gt;&gt; q.difference(s)set() difference_update( ) 从当前集合内删除所有与其他集合内相同的数据元素 1234567&gt;&gt;&gt; s = &#123;1, 2, 3&#125;&gt;&gt;&gt; q = &#123;2, 3&#125;&gt;&gt;&gt; s&#123;1, 2, 3&#125;&gt;&gt;&gt; s.difference_update(q)&gt;&gt;&gt; s&#123;1&#125; intersection( ) 交集 12345&gt;&gt;&gt; s = &#123;1, 2, 3&#125;&gt;&gt;&gt; q = &#123;2, 3&#125;&gt;&gt;&gt; r = s.intersection(q)&gt;&gt;&gt; r&#123;2, 3&#125; union( ) 并集 12345&gt;&gt;&gt; s = &#123;1, 2, 3&#125;&gt;&gt;&gt; q = &#123;2, 3, 4&#125;&gt;&gt;&gt; r = s.union(q)&gt;&gt;&gt; r&#123;1, 2, 3, 4&#125; remove( ) 删除集合内的某个指定元素 1234&gt;&gt;&gt; s = &#123;1, 2, 3&#125;&gt;&gt;&gt; s.remove(1)&gt;&gt;&gt; s&#123;2, 3&#125; update( ) 集合内添加多个元素（注意观察与 add() 的区别） 1234&gt;&gt;&gt; s = &#123;1, 2, 3&#125;&gt;&gt;&gt; s.update((4,5,6))&gt;&gt;&gt; s&#123;1, 2, 3, 4, 5, 6&#125; 更多关于集合数据类型的内建函数方法，可在 Python 交互式环境下，使用：help(set) 进行查看，或查阅官方文档：Python 官方文档。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 文件（下）]]></title>
    <url>%2FPython3-%E6%96%87%E4%BB%B6%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[–本篇主要讲述 Python数据类型之：文件– “优雅” “明确” “简单”Python 如果对文件基础部分的了解和操作还不清楚，可以查看文件（上）篇，传送门：Python3 文件（上） 本章将主要介绍在Python中：如何对 CSV、Excel 文件进行读写的相关操作。 CSV 文件CSV：C表示逗号，S表示分隔，V表示值，通俗的来说CSV即“逗号分隔值”。通常将数据库中存储的数据，以csv文件的形式来导出进行数据上的一些管理和交换等。 值得注意的是：有关csv文件的打开和阅读建议使用专门的csv文件阅读器，可自行搜索。非常不建议也不支持使用某软家的excel来进行管理，容易造成一些你意想不到的问题和麻烦，请慎重考虑。 CSV 文件读取有关csv文件操作，在Python内部已有相关模块集成，无需再安装，可以直接使用。通常这样导入：1import csv 假定我们实现存储好这样一个CSV文件，文件名为：“testcsv.csv”，形如：123456id,name,price,publictime1,第01行,10$,2100-10-102,第02行,11$,2100-10-113,第03行,12$,2100-10-124,第04行,13$,2100-10-135,第05行,14$,2100-10-14 我们的读取过程通常会是像这样的：123456&gt;&gt;&gt; import csv&gt;&gt;&gt; f = open(&quot;testcsv.csv&quot;, encoding=&quot;utf-8&quot;)&gt;&gt;&gt; f_csv = csv.reader(f)&gt;&gt;&gt; next(f_csv)[&apos;id&apos;, &apos;name&apos;, &apos;price&apos;, &apos;publictime&apos;]&gt;&gt;&gt; f.close() 解释：在CSV文件读取时，通常先创建一个文件对象，在上例中，我们的文件对象是 f，之后再使用csv模块的 reader() 函数来加载csv的文件对象 f，这样便拥有了一个csv文件操作的容器，本例是 f_csv。 csv的reader对象支持遍历： 1234567891011121314&gt;&gt;&gt; f = open(&quot;testcsv.csv&quot;, encoding=&quot;utf-8&quot;)&gt;&gt;&gt; f_csv = csv.reader(f)&gt;&gt;&gt; f_csv&lt;_csv.reader object at 0x000001A7084B83F0&gt;&gt;&gt;&gt; for row in f_csv:... print(row)...[&apos;id&apos;, &apos;name&apos;, &apos;price&apos;, &apos;publictime&apos;][&apos;1&apos;, &apos;第01行&apos;, &apos;10$&apos;, &apos;2100-10-10&apos;][&apos;2&apos;, &apos;第02行&apos;, &apos;11$&apos;, &apos;2100-10-11&apos;][&apos;3&apos;, &apos;第03行&apos;, &apos;12$&apos;, &apos;2100-10-12&apos;][&apos;4&apos;, &apos;第04行&apos;, &apos;13$&apos;, &apos;2100-10-13&apos;][&apos;5&apos;, &apos;第05行&apos;, &apos;14$&apos;, &apos;2100-10-14&apos;]&gt;&gt;&gt; f.close() 以字典表的方式读取 1234567891011&gt;&gt;&gt; f = open(&quot;testcsv.csv&quot;, encoding=&quot;utf-8&quot;)&gt;&gt;&gt; f_csv = csv.DictReader(f)&gt;&gt;&gt; for row in f_csv:... print(row)...OrderedDict([(&apos;id&apos;, &apos;1&apos;), (&apos;name&apos;, &apos;第01行&apos;), (&apos;price&apos;, &apos;10$&apos;), (&apos;publictime&apos;, &apos;2100-10-10&apos;)])OrderedDict([(&apos;id&apos;, &apos;2&apos;), (&apos;name&apos;, &apos;第02行&apos;), (&apos;price&apos;, &apos;11$&apos;), (&apos;publictime&apos;, &apos;2100-10-11&apos;)])OrderedDict([(&apos;id&apos;, &apos;3&apos;), (&apos;name&apos;, &apos;第03行&apos;), (&apos;price&apos;, &apos;12$&apos;), (&apos;publictime&apos;, &apos;2100-10-12&apos;)])OrderedDict([(&apos;id&apos;, &apos;4&apos;), (&apos;name&apos;, &apos;第04行&apos;), (&apos;price&apos;, &apos;13$&apos;), (&apos;publictime&apos;, &apos;2100-10-13&apos;)])OrderedDict([(&apos;id&apos;, &apos;5&apos;), (&apos;name&apos;, &apos;第05行&apos;), (&apos;price&apos;, &apos;14$&apos;), (&apos;publictime&apos;, &apos;2100-10-14&apos;)])&gt;&gt;&gt; f.close() CSV 文件写入假定我们要使用Python完成如下的一个csv文件内容的写入，内容如下：123id,name1,第01行2,第02行 以元组的形式实现写入：1234567891011121314151617181920&gt;&gt;&gt; import csv&gt;&gt;&gt; csv_header = [&quot;id&quot;, &quot;name&quot;]&gt;&gt;&gt; csv_row = [... (1, &quot;第01行&quot;),... (2, &quot;第02行&quot;)... ]&gt;&gt;&gt; with open(&quot;writecsv.csv&quot;, &quot;w&quot;, encoding=&quot;utf8&quot;, newline=&quot;&quot;) as f:... write_csv = csv.writer(f)... write_csv.writerow(csv_header)... write_csv.writerows(csv_row)...9&gt;&gt;&gt; with open(&quot;writecsv.csv&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:... reader = csv.reader(f)... for row in reader:... print(row)...[&apos;id&apos;, &apos;name&apos;][&apos;1&apos;, &apos;第01行&apos;][&apos;2&apos;, &apos;第02行&apos;] 以字典表的形式实现写入：12345678910111213141516&gt;&gt;&gt; import csv&gt;&gt;&gt; csv_header = [&quot;id&quot;, &quot;name&quot;]&gt;&gt;&gt; csv_row = [&#123;&quot;id&quot;:1, &quot;name&quot;:&quot;第01行&quot;&#125;, &#123;&quot;id&quot;:2, &quot;name&quot;:&quot;第02行&quot;&#125;]&gt;&gt;&gt; with open(&quot;dictwritecsv.csv&quot;, &quot;w&quot;, encoding=&quot;utf8&quot;, newline=&quot;&quot;) as f:... csv_write = csv.DictWriter(f, csv_header)... csv_write.writeheader()... csv_write.writerows(csv_row)...&gt;&gt;&gt; with open(&quot;dictwritecsv.csv&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:... reader = csv.reader(f)... for row in reader:... print(row)...[&apos;id&apos;, &apos;name&apos;][&apos;1&apos;, &apos;第01行&apos;][&apos;2&apos;, &apos;第02行&apos;] Excel 文件有关 Excel 文件的读写和操作，Python内部并没有直接可以使用的方法，需要借助额外的包： xlrd 用于读取 Excel 文件 xlwt 用于写入 Excel 文件 安装可以使用：12&gt;&gt;&gt; pip install xlrd&gt;&gt;&gt; pip install xlwt 注明：本篇将主讲解 xlrd 的读取相关的操作，有关 xlwt 的写入可查看相关资料。 xlrd 的使用通常我们的读取会像这样：12345678910111213import xlrddef xl_read(): &quot;&quot;&quot;Excel 文件读取&quot;&quot;&quot; book = xlrd.open_workbook(&quot;testexcel.xlsx&quot;) sheet = book.sheet_by_index(0) sheet_name = sheet.name # 可获取当前工作表的名称 sheet_rows = sheet.nrows # 可获取当前工作表的总行数 for row_index in range(sheet.nrows): print(sheet.row_values(row_index)) # 打印索引指定行的数据 相关解释： 使用 xlrd 读取 excel 文件，基本方法需要使用 open_workbook(&quot;excelfilename&quot;) 构建基本的读取器，这里我们定义为 book book 读取器建立后，要进一步指定我们所需要读取的是哪一张工作表的数据（众所周知excel文件内可以包含多个工作表，英文叫 sheet），而 book 为我们提供两种方法： sheet_by_name() 通过工作表的名称来指定 sheet_by_index() 通过工作表的索引来指定，默认从0开始 在上一步中，我们通过 sheet_by_index() 来创建了 sheet 对象，通过 sheet 对象，我们可以获取到一些基本的属性： name 当前读取表的表名 nrows 当前读取表有效数据的总行数 有了 sheet 对象，我们便可以通过 sheet.row_values() 来获取指定行的数据： sheet.row_values() 接受行的索引作为参数查询指定行的数据 一些需要说明的：xlrd 所读取的 excel 中每一行的数据，其返回的都是将该行每一个单元格内的数据转化为字符串，并以列表的形式返回。更为详细的可自行进行尝试打印来获取更准确的信息。 更多关于文件对象的操作，可查阅官方文档：Python 官方文档。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 文件（上）]]></title>
    <url>%2FPython3-%E6%96%87%E4%BB%B6%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[–本篇主要讲述 Python数据类型之：文件– “优雅” “明确” “简单”Python 说起文件，很多人可能并不认为这应当是一个数据类型，其实在Python当中：一切皆对象。而且在Python当中，文件的读写都是通过文件对象：file，来完成的。尽管将文件归为数据类型不太确切，但我们并不纠结于此，目的在于如何灵活的掌握和使用Python来完成对我们日常文件的管理需求。 在Python3中，文件默认会以UTF-8的编码进行读写。 文件都有很多类型，诸如：txt，excel，csv等。并且不同的文件类型，在读取和操作方面都有些各自的方法和特点，所以关于文件的讲解，分为上篇和下篇。本文为上篇，主要基于基本的文件类型：txt来进行，有关excel、csv等的讲解请看下篇，传送门： Python3 文件（下） 文件 File 对象的创建 基本的形式：1file = open(&apos;file&apos;, &quot;mode&quot;) r w a 是三种最基本的模式： r (read) 读取 W (write) 写入 a (append) 追加 更多 mode 参数所对应的值如下表： 模式 含义 r 以只读方式打开文件。文件指针指向文件开头，从头读取。（默认模式） rb 以二进制格式打开一个文件用于只读。 r+ 打开一个文件用于读写 rb+ 以二进制格式打开一个文件用于读写 w 只用于写入。文件存在则覆盖写入。文件不存在，则创建并写入 w+ 打开一个文件用于读写 wb+ 以二进制格式打开一个文件用于读写 a 追加模式，文件存在，文件指针指向文件结尾，从内容末尾开始写入 ab 二进制格式打开一个文件用于追加 a+ 打开一个文件用于读写，存在的文件进行追加，不存在则创建新文件 ab+ 二进制格式打开一个文件用于追加 文件 File 对象的基本操作 值得注意的是：所有文件对象操作的最后，都要对文件进行关闭，来结束所有操作并保存最终的结果；以避免下一次操作时发生冲突或者其他问题的产生。 文件 File 对象的部分属性 name 可以获取到当前文件对象的文件名 123&gt;&gt;&gt; f = open(&quot;testfile.txt&quot;, &quot;r&quot;)&gt;&gt;&gt; f.name&apos;testfile.txt&apos; mode 当前文件的模式 123&gt;&gt;&gt; f = open(&quot;testfile.txt&quot;, &quot;r&quot;)&gt;&gt;&gt; f.mode&apos;r&apos; closed 文件关闭状态，关闭为 True 123456&gt;&gt;&gt; f = open(&quot;testfile.txt&quot;, &quot;r&quot;)&gt;&gt;&gt; f.closedFalse&gt;&gt;&gt; f.close()&gt;&gt;&gt; f.closedTrue 基本操作 基本的写入： 1234&gt;&gt;&gt; f = open(&quot;testfile.txt&quot;, &quot;w&quot;)&gt;&gt;&gt; f.write(&quot;我写的第一行数据&quot;)8&gt;&gt;&gt; f.close() read(&quot;size&quot;) 从文件读取指定的字节数，如果未给定或为负则读取所有： 12345678910&gt;&gt;&gt; f = open(&quot;testfile.txt&quot;, &quot;r&quot;)&gt;&gt;&gt; f.read()&apos;我写的第一行数据&apos;&gt;&gt;&gt; f.close()&gt;&gt;&gt; f = open(&quot;testfile.txt&quot;, &quot;r&quot;)&gt;&gt;&gt; f.read(1)&apos;我&apos;&gt;&gt;&gt; f.read(2)&apos;写的&apos;&gt;&gt;&gt; f.close() readline(&quot;size&quot;) 逐行读取，包括 “\n” 字符，size指定读取当前行的字节数。 1234567891011&gt;&gt;&gt; f = open(&quot;testfile.txt&quot;, &quot;r&quot;)&gt;&gt;&gt; f.readline()&apos;我写的第一行数据\n&apos;&gt;&gt;&gt; f.readline()&apos;第二行数据\n&apos;&gt;&gt;&gt; f.readline()&apos;第三行数据\n&apos;&gt;&gt;&gt; f.close()&gt;&gt;&gt; f = open(&quot;testfile.txt&quot;, &quot;r&quot;)&gt;&gt;&gt; f.readline(1000)&apos;我写的第一行数据\n&apos; readlines() 读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。 12345678&gt;&gt;&gt; f = open(&quot;testfile.txt&quot;, &quot;r&quot;)&gt;&gt;&gt; f.readlines()[&apos;我写的第一行数据\n&apos;, &apos;第二行数据\n&apos;, &apos;第三行数据\n&apos;]&gt;&gt;&gt; f.close()&gt;&gt;&gt; f = open(&quot;testfile.txt&quot;, &quot;r&quot;)&gt;&gt;&gt; f.readlines(10)[&apos;我写的第一行数据\n&apos;, &apos;第二行数据\n&apos;]&gt;&gt;&gt; f.close() tell() 返回当前文件指针位置 1234567&gt;&gt;&gt; f = open(&quot;testfile.txt&quot;, &quot;r&quot;)&gt;&gt;&gt; f.tell()0&gt;&gt;&gt; f.readline()&apos;第一行\n&apos;&gt;&gt;&gt; f.tell()8 readable() 查看文件是否以读取模式打开，是则为True 12345678&gt;&gt;&gt; f = open(&quot;testfile.txt&quot;, &quot;r&quot;)&gt;&gt;&gt; f.readable()True&gt;&gt;&gt; f.close()&gt;&gt;&gt; f = open(&quot;testfile.txt&quot;, &quot;w&quot;)&gt;&gt;&gt; f.readable()False&gt;&gt;&gt; f.close() seek(cookie, whence=0, /) 按照给定的参考位置，重新调整指针的位置，whence可设定的数值为：0（默认值，以文件开头开始），1（当前指针位置开始），2（文件末尾处开始，此时cookie偏移数是不支持设定的，可以设定为0） 12345678910111213141516&gt;&gt;&gt; f = open(&quot;testfile.txt&quot;, &quot;r&quot;)&gt;&gt;&gt; f.tell()0&gt;&gt;&gt; f.readline()&apos;第一行\n&apos;&gt;&gt;&gt; f.tell()8&gt;&gt;&gt; f.seek(0,0)0&gt;&gt;&gt; f.readline()&apos;第一行\n&apos;&gt;&gt;&gt; f.seek(0,2)22&gt;&gt;&gt; f.readline()&apos;&apos;&gt;&gt;&gt; f.close() 二进制文件二进制文件在Python中，配合pickle，更适合进行一些Python对象的存储。 一个完整读写，通常类似这样：123456789&gt;&gt;&gt; f = open(&quot;testfile.pkl&quot;, &quot;wb&quot;)&gt;&gt;&gt; d = &#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;&gt;&gt;&gt; import pickle&gt;&gt;&gt; pickle.dump(d, f)&gt;&gt;&gt; f.close()&gt;&gt;&gt; f = open(&quot;testfile.pkl&quot;, &quot;rb&quot;)&gt;&gt;&gt; data = pickle.load(f)&gt;&gt;&gt; data&#123;&apos;a&apos;: 1, &apos;b&apos;: 2&#125; 文件操作的注意事项每次对文件对象的操作结束后，将文件关闭是一个良好的编码习惯，也是最为安全和必要的行为；每次对文件对象的操作结束后，将文件关闭是一个良好的编码习惯，也是最为安全和必要的行为；每次对文件对象的操作结束后，将文件关闭是一个良好的编码习惯，也是最为安全和必要的行为； 有一种更为简便的方式可以更快捷的完成对文件的操作并且可以不用担心文件没有被关闭，那便是上下文操作，使用 with 语句，通常像是这样的使用：123456789&gt;&gt;&gt; with open(&quot;testfile.txt&quot;, &quot;r&quot;) as f:... for line in f.readlines():... print(line)...第一行第二行第三行 更多关于文件对象的操作，可查阅官方文档：Python 官方文档。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 字典表]]></title>
    <url>%2FPython3-%E5%AD%97%E5%85%B8%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[–本篇主要讲述 Python数据类型之：字典表– “优雅” “明确” “简单”Python Python中的数据类型：字典表。并且字典表数据类型支持原位改变。字典表内的每一个元素，都是以键值（key=&gt;value）对的形式组成，键值对用冒号(:)分割，每个元素之间用逗号（,）分割，整个字典包括在花括号（{}）中 ,格式如下所示：123&gt;&gt;&gt; d = &#123;&apos;key1&apos;:&apos;value1&apos;, &apos;key2&apos;:&apos;value2&apos;, &apos;key3&apos;:&apos;value3&apos;&#125;&gt;&gt;&gt; type(d)&lt;class &apos;dict&apos;&gt; 注意：字典表的键必须是唯一的，但值则不必。值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。 字典表的声明 使用基本的形式进行定义： 123&gt;&gt;&gt; d = &#123;&apos;key1&apos;:&apos;value1&apos;, &apos;key2&apos;:&apos;value2&apos;, &apos;key3&apos;:&apos;value3&apos;&#125;&gt;&gt;&gt; type(d)&lt;class &apos;dict&apos;&gt; 使用 dict( ) 进行声明： 12345&gt;&gt;&gt; d = dict(name=&apos;python&apos;, verison=&apos;3.6&apos;)&gt;&gt;&gt; d&#123;&apos;name&apos;: &apos;python&apos;, &apos;verison&apos;: &apos;3.6&apos;&#125;&gt;&gt;&gt; type(d)&lt;class &apos;dict&apos;&gt; 字典表的基本访问 基本访问形式，类似索引的方式，但是字典表使用的是[key]的形式来访问： 12345&gt;&gt;&gt; d = &#123;&apos;key1&apos;:&apos;value1&apos;, &apos;key2&apos;:&apos;value2&apos;, &apos;key3&apos;:&apos;value3&apos;&#125;&gt;&gt;&gt; d[&apos;key1&apos;]&apos;value1&apos;&gt;&gt;&gt; d[&apos;key3&apos;]&apos;value3&apos; 使用字典表的内置方法：dit.get( )： 12345&gt;&gt;&gt; d = &#123;&apos;key1&apos;:&apos;value1&apos;, &apos;key2&apos;:&apos;value2&apos;, &apos;key3&apos;:&apos;value3&apos;&#125;&gt;&gt;&gt; d.get(&apos;key1&apos;)&apos;value1&apos;&gt;&gt;&gt; d.get(&apos;key2&apos;)&apos;value2&apos; 二者访问的区别：第一种方式，访问不存在的键时，会直接报错；第二种方式可以避免在访问不存在的键时发生的错误，并且可以给出未找到时的默认返回内容。1234567&gt;&gt;&gt; d = &#123;&apos;key1&apos;:&apos;value1&apos;, &apos;key2&apos;:&apos;value2&apos;, &apos;key3&apos;:&apos;value3&apos;&#125;&gt;&gt;&gt; d[&apos;key4&apos;]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: &apos;key4&apos;&gt;&gt;&gt; d.get(&apos;key4&apos;, &apos;未找到该元素&apos;)&apos;未找到该元素&apos; 字典表的修改与添加 修改字典表内已有的元素： 1234&gt;&gt;&gt; d = &#123;&apos;key1&apos;:&apos;value1&apos;, &apos;key2&apos;:&apos;value2&apos;, &apos;key3&apos;:&apos;value3&apos;&#125;&gt;&gt;&gt; d[&apos;key1&apos;] = &apos;我修改了key1的值&apos;&gt;&gt;&gt; d&#123;&apos;key1&apos;: &apos;我修改了key1的值&apos;, &apos;key2&apos;: &apos;value2&apos;, &apos;key3&apos;: &apos;value3&apos;&#125; 通过基本的赋值（字典表内没有的键）来增加元素： 1234&gt;&gt;&gt; d = &#123;&apos;key1&apos;:&apos;value1&apos;, &apos;key2&apos;:&apos;value2&apos;, &apos;key3&apos;:&apos;value3&apos;&#125;&gt;&gt;&gt; d[&apos;add&apos;] = &apos;success&apos;&gt;&gt;&gt; d&#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;, &apos;key3&apos;: &apos;value3&apos;, &apos;add&apos;: &apos;success&apos;&#125; 基本操作 len( ) 计算字典表的元素个数： 1234&gt;&gt;&gt; d = &#123;&apos;key1&apos;:&apos;value1&apos;, &apos;key2&apos;:&apos;value2&apos;, &apos;key3&apos;:&apos;value3&apos;&#125;&gt;&gt;&gt; len(d)3&gt;&gt; 字典表内置函数 clear( ) 删除字典表内所有元素： 123456&gt;&gt;&gt; d = &#123;&apos;a&apos;:1, &apos;b&apos;:2, &apos;c&apos;:3&#125;&gt;&gt;&gt; d&#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;&gt;&gt;&gt; d.clear()&gt;&gt;&gt; d&#123;&#125; 字典表内置函数 copy( ) 复制并返回字典表内所有元素： 123&gt;&gt;&gt; d = &#123;&apos;a&apos;:1, &apos;b&apos;:2, &apos;c&apos;:3&#125;&gt;&gt;&gt; d.copy()&#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125; 字典表内置函数 fromkeys( ) 根据指定的可迭代对象创建含有初始值的字典表： 123456789&gt;&gt;&gt; d = &#123;&#125;&gt;&gt;&gt; fk = (&apos;x&apos;, &apos;y&apos;, &apos;z&apos;)&gt;&gt;&gt; d.fromkeys(fk, 0)&#123;&apos;x&apos;: 0, &apos;y&apos;: 0, &apos;z&apos;: 0&#125;&gt;&gt;&gt; d&#123;&#125;&gt;&gt;&gt; newd = d.fromkeys(fk, 0)&gt;&gt;&gt; newd&#123;&apos;x&apos;: 0, &apos;y&apos;: 0, &apos;z&apos;: 0&#125; 字典表内置函数 get( ) 获取字典表内某键的值： 123456789&gt;&gt;&gt; d = &#123;&apos;a&apos;:1, &apos;b&apos;:2, &apos;c&apos;:3&#125;&gt;&gt;&gt; d.get(&apos;a&apos;)1&gt;&gt;&gt; result = d.get(&apos;d&apos;)&gt;&gt;&gt; result&gt;&gt;&gt; type(result)&lt;class &apos;NoneType&apos;&gt;&gt;&gt;&gt; d.get(&apos;d&apos;, &apos;noresult&apos;)&apos;noresult&apos; 字典表内置函数 items( ) 返回可遍历的(键, 值) 元组数组： 123&gt;&gt;&gt; d = &#123;&apos;a&apos;:1, &apos;b&apos;:2, &apos;c&apos;:3&#125;&gt;&gt;&gt; d.items()dict_items([(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 3)]) 字典表内置函数 keys( ) 返回一个字典所有的键： 123&gt;&gt;&gt; d = &#123;&apos;a&apos;:1, &apos;b&apos;:2, &apos;c&apos;:3&#125;&gt;&gt;&gt; d.keys()dict_keys([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]) 字典表内置函数 pop( ) 删除字典表内的指定元素并返回键对应的值，同时可指定异常时的返回内容： 123456789&gt;&gt;&gt; d = &#123;&apos;a&apos;:1, &apos;b&apos;:2, &apos;c&apos;:3&#125;&gt;&gt;&gt; d.pop(&apos;a&apos;)1&gt;&gt;&gt; d.pop(&apos;e&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: &apos;e&apos;&gt;&gt;&gt; d.pop(&apos;e&apos;, &apos;未找到&apos;)&apos;未找到&apos; 字典表内置函数 update( ) 把字典dict2的键/值对更新到dict里： 12345&gt;&gt;&gt; d = &#123;&apos;a&apos;:1, &apos;b&apos;:2, &apos;c&apos;:3&#125;&gt;&gt;&gt; newd = &#123;&apos;x&apos;:4&#125;&gt;&gt;&gt; d.update(newd)&gt;&gt;&gt; d&#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3, &apos;x&apos;: 4&#125; 字典表内置函数 values( ) 返回字典中的所有值： 123&gt;&gt;&gt; d = &#123;&apos;a&apos;:1, &apos;b&apos;:2, &apos;c&apos;:3&#125;&gt;&gt;&gt; d.values()dict_values([1, 2, 3]) 更多关于字典表数据类型的内建函数方法，可在 Python 交互式环境下，使用：help(dict) 进行查看，或查阅官方文档：Python 官方文档。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 元组]]></title>
    <url>%2FPython3-%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[–本篇主要讲述 Python数据类型之：元组– “优雅” “明确” “简单”Python Python中的数据类型：元组。并且元组的元素不能修改。以括号 ( ) 括起来，每个数据（元素）之间使用英文的逗号 ‘,’ 进行分隔的形式书写的字面值在Python中为元组数据类型。形如：123&gt;&gt;&gt; t = (&apos;a&apos;, 1, 2, &apos;hello&apos;)&gt;&gt;&gt; type(t)&lt;class &apos;tuple&apos;&gt; 在Python中，元组数据类型英文称作：“ tuple ”。 相关的方法等示例展示，均以Python的交互式环境演示为主！ 元组数据类型的特性 任意对象的有序集合； 通过索引下标访问元素（第一个索引是0，第二个索引是1，依次类推）； 长度固定，任意类型，任意嵌套； 属于不可变类型； 元组数据类型的声明方式 使用基本形式括号 ( ) 定义 123&gt;&gt;&gt; t = (&apos;a&apos;, 1, 2, &apos;hello&apos;)&gt;&gt;&gt; type(t)&lt;class &apos;tuple&apos;&gt; tuple( ) 使用 tuple 构造函数构造元组 123&gt;&gt;&gt; t = tuple(&apos;abc&apos;)&gt;&gt;&gt; t(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) 值得注意的是，当需要声明只有单个元素的元组时，”,”英文逗号不可缺少 12345&gt;&gt;&gt; t = (&apos;a&apos;,)&gt;&gt;&gt; t(&apos;a&apos;,)&gt;&gt;&gt; type(t)&lt;class &apos;tuple&apos;&gt; 基本操作 + 元组之间的连接组合 12345&gt;&gt;&gt; t1 = (1, 2, 3)&gt;&gt;&gt; t2 = (&apos;a&apos;, &apos;b&apos;)&gt;&gt;&gt; t3 = t1 + t2&gt;&gt;&gt; t3(1, 2, 3, &apos;a&apos;, &apos;b&apos;) * 重复操作，元组内元素的重复 123&gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;)&gt;&gt;&gt; t * 2(&apos;a&apos;, &apos;b&apos;, &apos;a&apos;, &apos;b&apos;) len( ) 计算元组长度（相当于元组内元素个数） 123&gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;)&gt;&gt;&gt; len(t)2 [ ] 通过索引获取元组内指定索引处的元素 123&gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)&gt;&gt;&gt; t[1]&apos;b&apos; tuple[x:y:z] 元组的切片操作（索引由左至右，从0开始）x：为切片起始索引y：为切片结束索引（结果不包含y索引位置的值）z：切片操作的步长 1234567891011&gt;&gt;&gt; t = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)&gt;&gt;&gt; t[3:5](4, 5)&gt;&gt;&gt; t[-1]10&gt;&gt;&gt; t[:](1, 2, 3, 4, 5, 6, 7, 8, 9, 10)&gt;&gt;&gt; t[::2](1, 3, 5, 7, 9)&gt;&gt;&gt; t[::-1](10, 9, 8, 7, 6, 5, 4, 3, 2, 1) in 成员运算符 - 判断指定元素是否存在于元组内，存在则为 True， 反之为 False 12345&gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)&gt;&gt;&gt; &apos;a&apos; in tTrue&gt;&gt;&gt; &apos;x&apos; in tFalse not in 成员运算符 - 判断指定元素是否存在于元组内，不存在则为 True， 反之为 False 12345&gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)&gt;&gt;&gt; &apos;x&apos; not in tTrue&gt;&gt;&gt; &apos;a&apos; not in tFalse 元组数据类型的常见内建函数 index( ) 从元组中找出某个值第一个匹配项的索引位置（可指定寻找的起止索引位置） 123456789&gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;, 1, &apos;c&apos;, 2, 3)&gt;&gt;&gt; t.index(&apos;b&apos;)1&gt;&gt;&gt; t.index(&apos;b&apos;, 2, 4)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: tuple.index(x): x not in tuple&gt;&gt;&gt; t.index(&apos;b&apos;, 1, 4)1 count( ) 统计元组中某元素出现的次数 1234567&gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;, &apos;a&apos;, &apos;c&apos;, &apos;b&apos;)&gt;&gt;&gt; t.count(&apos;a&apos;)2&gt;&gt;&gt; t.count(&apos;b&apos;)2&gt;&gt;&gt; t.count(&apos;c&apos;)1 更多关于元组数据类型的内建函数方法，可在 Python 交互式环境下，使用：help(tuple) 进行查看，或查阅官方文档：Python 官方文档。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 列表]]></title>
    <url>%2FPython3-%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[–本篇主要讲述 Python数据类型之：列表– “优雅” “明确” “简单”Python Python中的数据类型：列表。并且列表数据类型支持原位改变。以方括号 [ ] 括起来，每个数据之间使用英文的逗号 ‘,’ 进行分隔的形式书写的字面值在Python中为列表数据类型。形如：123&gt;&gt;&gt; L = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, 1, 2, 3]&gt;&gt;&gt; type(L)&lt;class &apos;list&apos;&gt; 在Python中，列表数据类型英文称作：“ list ”。 相关的方法等示例展示，均以Python的交互式环境演示为主！ 列表数据类型的特性 任意对象的有序集合； 通过索引下标访问元素（第一个索引是0，第二个索引是1，依次类推）； 可变长度； 属于可变序列； 列表数据类型的声明方式 使用基本形式方括号 [ ] 定义 123&gt;&gt;&gt; L = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, 1, 2, 3]&gt;&gt;&gt; type(L)&lt;class &apos;list&apos;&gt; list( ) 使用 list 构造函数构造列表 12345678910&gt;&gt;&gt; l = list((&apos;xyz&apos;, &apos;abc&apos;))&gt;&gt;&gt; l[&apos;xyz&apos;, &apos;abc&apos;]&gt;&gt;&gt; type(l)&lt;class &apos;list&apos;&gt;&gt;&gt;&gt; L = list(&apos;abc&apos;)&gt;&gt;&gt; L[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]&gt;&gt;&gt; type(L)&lt;class &apos;list&apos;&gt; 列表推导 12345&gt;&gt;&gt; l = [x**2 for x in range(5)]&gt;&gt;&gt; l[0, 1, 4, 9, 16]&gt;&gt;&gt; type(l)&lt;class &apos;list&apos;&gt; 基本操作 + 加法操作，列表之间的组合 1234&gt;&gt;&gt; L = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]&gt;&gt;&gt; l = [1,2,3]&gt;&gt;&gt; L + l[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, 1, 2, 3] * 重复操作，列表内元素的重复 123&gt;&gt;&gt; L = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]&gt;&gt;&gt; L * 5[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;] len( ) 计算列表长度（相当于列表内元素个数） 123&gt;&gt;&gt; L = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]&gt;&gt;&gt; len(L)3 [ ] 通过索引获取列表内指定索引处的元素 123&gt;&gt;&gt; L = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]&gt;&gt;&gt; L[1]&apos;b&apos; list[x:y:z] 列表的切片操作（索引由左至右，从0开始）x：为切片起始索引y：为切片结束索引（结果不包含y索引位置的值）z：切片操作的步长 1234567891011&gt;&gt;&gt; L = [1,2,3,4,5,6,7,8,9,10]&gt;&gt;&gt; L[3:5][4, 5]&gt;&gt;&gt; L[-1]10&gt;&gt;&gt; L[:][1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; L[::2][1, 3, 5, 7, 9]&gt;&gt;&gt; L[::-1][10, 9, 8, 7, 6, 5, 4, 3, 2, 1] in 成员运算符 - 判断指定元素是否存在于列表内，存在则为 True， 反之为 False 12345&gt;&gt;&gt; L = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]&gt;&gt;&gt; &apos;a&apos; in LTrue&gt;&gt;&gt; &apos;x&apos; in LFalse not in 成员运算符 - 判断指定元素是否存在于列表内，不存在则为 True， 反之为 False 12345&gt;&gt;&gt; L = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]&gt;&gt;&gt; &apos;x&apos; not in LTrue&gt;&gt;&gt; &apos;a&apos; not in LFalse 列表数据类型的常见内建函数 append( ) 在列表末尾添加新的对象 123456789&gt;&gt;&gt; l = [&apos;a&apos;, &apos;b&apos;]&gt;&gt;&gt; l.append(&apos;c&apos;)&gt;&gt;&gt; l[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]&gt;&gt;&gt; l = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]&gt;&gt;&gt; b = [1, 2, 3]&gt;&gt;&gt; l.append(b)&gt;&gt;&gt; l[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, [1, 2, 3]] clear( ) 清空列表中所有的元素 1234&gt;&gt;&gt; l = [&apos;a&apos;, 1, 2, &apos;b&apos;]&gt;&gt;&gt; l.clear()&gt;&gt;&gt; l[] copy( ) 复制列表 123456&gt;&gt;&gt; l = [&apos;a&apos;, 1, 2, &apos;b&apos;]&gt;&gt;&gt; s = l.copy()&gt;&gt;&gt; s[&apos;a&apos;, 1, 2, &apos;b&apos;]&gt;&gt;&gt; l[&apos;a&apos;, 1, 2, &apos;b&apos;] count( ) 统计列表中某元素出现的次数 1234567&gt;&gt;&gt; l = [&apos;a&apos;, &apos;b&apos;, &apos;a&apos;, &apos;c&apos;, &apos;b&apos;]&gt;&gt;&gt; l.count(&apos;a&apos;)2&gt;&gt;&gt; l.count(&apos;b&apos;)2&gt;&gt;&gt; l.count(&apos;c&apos;)1 extend( ) 在列表末尾一次性追加另一个序列中的多个值（可用新列表扩展原来的列表） 12345&gt;&gt;&gt; l = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]&gt;&gt;&gt; b = [1, 2, 3]&gt;&gt;&gt; l.extend(b)&gt;&gt;&gt; l[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, 1, 2, 3] index( ) 从列表中找出某个值第一个匹配项的索引位置（可指定寻找的起止索引位置） 123456789&gt;&gt;&gt; l = [&apos;a&apos;, &apos;b&apos;, 1, &apos;c&apos;, 2, 3]&gt;&gt;&gt; l.index(&apos;b&apos;)1&gt;&gt;&gt; l.index(&apos;b&apos;, 2, 4)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: &apos;b&apos; is not in list&gt;&gt;&gt; l.index(&apos;b&apos;, 1, 4)1 insert( ) 在列表中的指定位置处，插入某个对象 1234&gt;&gt;&gt; l = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]&gt;&gt;&gt; l.insert(1, [1, 2, 3])&gt;&gt;&gt; l[&apos;a&apos;, [1, 2, 3], &apos;b&apos;, &apos;c&apos;, &apos;d&apos;] pop( ) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 12345678910111213&gt;&gt;&gt; l = [1, 2, 3, 4, 5]&gt;&gt;&gt; p = l.pop()&gt;&gt;&gt; p5&gt;&gt;&gt; l[1, 2, 3, 4]&gt;&gt;&gt; s = l.pop(2)&gt;&gt;&gt; s3&gt;&gt;&gt; l[1, 2, 4]&gt;&gt;&gt; l.pop(1)2 remove( ) 移除列表中某个值的第一个匹配项 1234&gt;&gt;&gt; l = [&apos;hello&apos;, &apos;new year&apos;, &apos;all world&apos;, &apos;new year&apos;]&gt;&gt;&gt; l.remove(&apos;new year&apos;)&gt;&gt;&gt; l[&apos;hello&apos;, &apos;all world&apos;, &apos;new year&apos;] reverse( ) 反向重新排序列表中元素 1234&gt;&gt;&gt; l = [1, &apos;hello&apos;, &apos;new year&apos;, &apos;all world&apos;, &apos;new year&apos;, 10]&gt;&gt;&gt; l.reverse()&gt;&gt;&gt; l[10, &apos;new year&apos;, &apos;all world&apos;, &apos;new year&apos;, &apos;hello&apos;, 1] sort( ) 对列表进行排序（也可在排序后进行反向排序） 12345678&gt;&gt;&gt; l = [9, 1, 2, 6, 100, 3, 7, 5]&gt;&gt;&gt; l.sort()&gt;&gt;&gt; l[1, 2, 3, 5, 6, 7, 9, 100]&gt;&gt;&gt; l = [9, 1, 2, 6, 100, 3, 7, 5]&gt;&gt;&gt; l.sort(reverse=True)&gt;&gt;&gt; l[100, 9, 7, 6, 5, 3, 2, 1] 更多关于列表数据类型的内建函数方法，可在 Python 交互式环境下，使用：help(list) 进行查看，或查阅官方文档：Python 官方文档。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 字符串]]></title>
    <url>%2FPython3-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[–本篇主要讲述 Python数据类型之：字符串– “优雅” “明确” “简单”Python Python中的数据类型：字符串。并且字符串类型不支持原位改变。以引号括起来进行书写的字面值在Python中为字符串类型。 Python2中，普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀 u 表示 Unicode 字符串。Python3中，所有的字符串默认都是Unicode字符串。 相关的方法等示例展示，均以Python的交互式环境演示为主！ 有关四种不同形式的字符串声明 单引号 （使用单引号保留原字符串内的双引号而无需转换） 12&gt;&gt;&gt; print(&apos;happy &quot;new&quot; year&apos;)happy &quot;new&quot; year 双引号 （使用双引号保留原字符串内的单引号而无需转换） 12&gt;&gt;&gt; print(&quot;happy &apos;new&apos; year&quot;)happy &apos;new&apos; year 三引号 （允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。） 1234567891011&gt;&gt;&gt; para_str = &quot;&quot;&quot;这是一个多行字符串的实例···多行字符串可以使用制表符···TAB ( \t )。···也可以使用换行符 [ \n ]。···&quot;&quot;&quot;&gt;&gt;&gt; print(para_str)这是一个多行字符串的实例多行字符串可以使用制表符TAB ( )。也可以使用换行符 [ ]。 以 r 开头声明的原始字符串 （原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。） 12345&gt;&gt;&gt; path = r&apos;c:\abc\xyz.txt&apos;&gt;&gt;&gt; path&apos;c:\\abc\\xyz.txt&apos;&gt;&gt;&gt; print(path)c:\abc\xyz.txt Python字符串中的一些特殊字符使用反斜杠 \ 转义，常用的转义字符如下表 转义字符 实际输出结果 \\ \ 反斜杠符号 \&#39; &#39; 单引号 \&quot; &quot; 双引号 \n 换行符 \b 退格(Backspace) \t 制表符（四空格） \r 回车 \a 系统响铃 基本操作 + 加法操作，字符串连接 12&gt;&gt;&gt; &apos;abc&apos; + &apos;xyz&apos;&apos;abcxyz&apos; * 重复操作，重复输出字符串 12&gt;&gt;&gt; &apos;ok&apos; * 5&apos;okokokokok&apos; len( ) 计算长度 12&gt;&gt;&gt; len(&apos;ok&apos;)2 [ ] 通过索引获取字符串中对应索引处的字符 12345&gt;&gt;&gt; s = &apos;hello python&apos;&gt;&gt;&gt; s[0]&apos;h&apos;&gt;&gt;&gt; s[-1]&apos;n&apos; str[x:y:z] 切片操作（索引由左至右，从0开始）x：为切片起始索引y：为切片结束索引（结果不包含y索引位置的值）z：切片操作的步长 1234567891011&gt;&gt;&gt; s = &apos;my name is python w&apos;&gt;&gt;&gt; s[3:7]&apos;name&apos;&gt;&gt;&gt; s[-1]&apos;w&apos;&gt;&gt;&gt; s[:]&apos;my name is python w&apos;&gt;&gt;&gt; s[::2]&apos;m aei yhnw&apos;&gt;&gt;&gt; s[::-1]&apos;w nohtyp si eman ym&apos; ord( ) 与 chr( ) 字母与数字对应转化 1234&gt;&gt;&gt; ord(&apos;c&apos;)99&gt;&gt;&gt; chr(99)&apos;c&apos; in 成员运算符 - 如果字符串中包含给定的字符返回 True 123&gt;&gt;&gt; s = &apos;hello python&apos;&gt;&gt;&gt; &apos;python&apos; in sTrue not in 成员运算符 - 如果字符串中不包含给定的字符返回 True 123&gt;&gt;&gt; s = &apos;hello python&apos;&gt;&gt;&gt; &apos;python&apos; not in sFalse 字符串类型的常见内建函数 replace( ) 替换字符串 （字符串不支持原位改变，替换后结果需重新赋值给新变量）。 123&gt;&gt;&gt; s = &quot;hello world&quot;&gt;&gt;&gt; s.replace(&apos;o&apos;, &apos;k&apos;)&apos;hellk wkrld&apos; split() 以给定字符为分隔符截取字符串，可指定分割次数。分割结果以列表数据类型返回。 12345&gt;&gt;&gt; s = &quot;hello world&quot;&gt;&gt;&gt; s.split(&apos;o&apos;)[&apos;hell&apos;, &apos; w&apos;, &apos;rld&apos;]&gt;&gt;&gt; s.split(&apos;o&apos;,1)[&apos;hell&apos;, &apos; world&apos;] capitalize( ) 将字符串首字母转化为大写。 123&gt;&gt;&gt; s = &apos;hello world&apos;&gt;&gt;&gt; s.capitalize()&apos;Hello world&apos; startswith( ) 判断字符串开始，返回结果为 True 或 False。 12345&gt;&gt;&gt; s = &apos;hello world&apos;&gt;&gt;&gt; s.startswith(&apos;he&apos;)True&gt;&gt;&gt; s.startswith(&apos;kk&apos;)False endswith( ) 判断字符串结尾，返回结果为 True 或 False。 12345&gt;&gt;&gt; s = &apos;hello world&apos;&gt;&gt;&gt; s.endswith(&apos;ld&apos;)True&gt;&gt;&gt; s.endswith(&apos;oo&apos;)False count( ) 统计指定字符出现的频率，也可（根据索引）指定统计起止位置。 12345&gt;&gt;&gt; s = &apos;hello world&apos;&gt;&gt;&gt; s.count(&apos;o&apos;)2&gt;&gt;&gt; s.count(&apos;o&apos;, 0, 5)1 find( ) 统计指定字符出现的频率，也可（根据索引）指定查找起止范围。 12345&gt;&gt;&gt; s = &apos;hello world&apos;&gt;&gt;&gt; s.count(&apos;o&apos;)2&gt;&gt;&gt; s.count(&apos;o&apos;, 0, 5)1 format( ) 字符串格式化，使用 format 内传递的内容格式化字符串内指定位置。 12345&gt;&gt;&gt; a = &apos;&#123;&#125; hello python &#123;&#125;&apos;&gt;&gt;&gt; a.format(&apos;abc&apos;,&apos;xyz&apos;)&apos;abc hello python xyz&apos;&gt;&gt;&gt; &apos;&#123;&#125;ello &#123;&#125;ython&apos;.format(&apos;h&apos;, &apos;p&apos;)&apos;hello python&apos; isalnum( ) 判断字符串是否只包含字母或数字，是则返回 True，否则返回 False。 123456&gt;&gt;&gt; s = &apos;hello python 3&apos;&gt;&gt;&gt; s.isalnum()False&gt;&gt;&gt; s = &apos;hellopython3&apos;&gt;&gt;&gt; s.isalnum()True isalpha( ) 判断字符串是否只包含字母，是则返回 True，否则返回 False。 123456&gt;&gt;&gt; s = &apos;hello python 3&apos;&gt;&gt;&gt; s.isalpha()False&gt;&gt;&gt; s = &apos;hellopython&apos;&gt;&gt;&gt; s.isalpha()True isdigit( ) 判断字符串是否只包含数字，是则返回 True，否则返回 False。 123456&gt;&gt;&gt; s = &apos;3.6&apos;&gt;&gt;&gt; s.isdigit()False&gt;&gt;&gt; s = &apos;36&apos;&gt;&gt;&gt; s.isdigit()True islower( ) 判断字符串中的所有字母是否为小写，是则返回 True，否则返回 False。 123456&gt;&gt;&gt; s = &apos;a36a&apos;&gt;&gt;&gt; s.islower()True&gt;&gt;&gt; s = &apos;a36A&apos;&gt;&gt;&gt; s.islower()False isupper( ) 判断字符串中的所有字母是否为大写，是则返回 True，否则返回 False。 123456&gt;&gt;&gt; s = &apos;A36A&apos;&gt;&gt;&gt; s.isupper()True&gt;&gt;&gt; s = &apos;A36a&apos;&gt;&gt;&gt; s.isupper()False lower( ) 将字符串中的所有字母转换为小写。 123&gt;&gt;&gt; s = &apos;HELLO PYTHON 3.6&apos;&gt;&gt;&gt; s.lower()&apos;hello python 3.6&apos; upper( ) 将字符串中的所有字母转换为大写。 123&gt;&gt;&gt; s = &apos;hello python 3.6&apos;&gt;&gt;&gt; s.upper()&apos;HELLO PYTHON 3.6&apos; swapcase( ) 将字符串中的所有字母：大写转换为小写，小写转换为大写。 123&gt;&gt;&gt; s = &apos;hello python, HELLO PYTHON&apos;&gt;&gt;&gt; s.swapcase()&apos;HELLO PYTHON, hello python&apos; join( ) 以字符串本身作为分隔符，将 join 函数内部迭代器的所有元素进行拼接。 123456&gt;&gt;&gt; s = &apos;hello&apos;&gt;&gt;&gt; L = [&apos;Today &apos;, &apos; python &apos;, &apos; world&apos;]&gt;&gt;&gt; s.join(L)&apos;Today hello python hello world&apos;&gt;&gt;&gt; &apos;.&apos;.join([&apos;www&apos;, &apos;python&apos;, &apos;org&apos;])&apos;www.python.org&apos; lstrip( ) 去除字符串起始处的空格。 123&gt;&gt;&gt; s = &apos; hello python &apos;&gt;&gt;&gt; s.lstrip()&apos;hello python &apos; rstrip( ) 去除字符串结尾处的空格。 123&gt;&gt;&gt; s = &apos; hello python &apos;&gt;&gt;&gt; s.rstrip()&apos; hello python&apos; strip( ) 去除开头儿和结尾的空格（相当于同时执行了：lstrip( ) 和 rstrip( )） 123&gt;&gt;&gt; s = &apos; hello python &apos;&gt;&gt;&gt; s.strip()&apos;hello python&apos; 更多关于字符串数据类型的内建函数方法，可在 Python 交互式环境下，使用：help(str) 进行查看，或查阅官方文档：Python 官方文档。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 数字]]></title>
    <url>%2FPython3-%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[–本篇主要讲述 Python数据类型之：数字– “优雅” “明确” “简单”Python Python中的数字数据类型用于存储数值。常见的就如我们数学中所使用的数字等。 在Python中，数字数据类型不支持原位改变，要改变变量的数字数据类型，只能通过重新复制来改变，而原数据本身是不被改变的。 相关的方法等示例展示，均以Python的交互式环境演示为主！ Python 支持三种不同的数值类型 整型(Int) - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。 浮点型(float) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250） 复数( (complex)) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。 Decimal 数据类型，需要使用模块decimal，引入：import decimal。使用如：123&gt;&gt;&gt; import decimal&gt;&gt;&gt; decimal.Decimal(&apos;1.1&apos;) + decimal.Decimal(&apos;2.2&apos;)Decimal(&apos;3.3&apos;) 常见的进制有： 十六进制：以 0x 开头表示 八进制：以 0o 开头表示 二进制：以 0b 开头表示 各进制转换 hex( ) 转换为十六进制 oct( ) 转换为八进制 bin( ) 转换为二进制123456&gt;&gt;&gt; oct(64)&apos;0o100&apos;&gt;&gt;&gt; hex(64)&apos;0x40&apos;&gt;&gt;&gt; bin(64)&apos;0b1000000&apos; Python 数字类型转换有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。 int(x) 将x转换为一个整数。 12&gt;&gt;&gt; int(1.1)1 float(x) 将x转换到一个浮点数。 12&gt;&gt;&gt; float(1)1.0 complex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0。 12&gt;&gt;&gt; complex(1)(1+0j) complex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。 12&gt;&gt;&gt; comlex(1, 2)(1+2j) 基本的格式化使用&quot;&quot;.format()，例如保留两位小数，如下： 123&gt;&gt;&gt; f = 3.33333&gt;&gt;&gt; &quot;f = &#123;0:.2f&#125;&quot;.format(f)&apos;f = 3.33&apos; 数字类型的比较，返回结果为：True 或 False有： &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 == 等于 != 不等于 例：12&gt;&gt;&gt; 1 &gt; 2False 数字数据类型的的运算计算结果保留类型以精度高的数据类型为准。 加法: + 12&gt;&gt;&gt; 1 + 12 减法：- 12&gt;&gt;&gt; 2 - 11 乘法：* 123&gt;&gt;&gt; 2 * 24&gt;&gt;&gt; 2 * 2.0 除法：/ （该计算结果保留小数） 12&gt;&gt;&gt; 3 / 21.5 整除：// （该计算结果只保留整数部分） 1234&gt;&gt;&gt; 3 / 21&gt;&gt;&gt; 3 / 2.01.0 取余：% （返回除法的余数） 12&gt;&gt;&gt; 9 / 45 幂运算：** （幂数运算） 12&gt;&gt;&gt; 5 ** 3125 小数部分操作相关的方法 floor( ) 在数字坐标轴中，向左取整（使用前需要先导入：import math） 12345678&gt;&gt;&gt; math.floor(3.4)3&gt;&gt;&gt; math.floor(3.9)3&gt;&gt;&gt; math.floor(-3.4)-4&gt;&gt;&gt; math.floor(-3.9)-4 trunc( ) 在数字坐标轴中，从两边向中间（坐标原点数字0处）取整（使用前需要先导入：import math） 12345678&gt;&gt;&gt; math.trunc(3.14)3&gt;&gt;&gt; math.trunc(3.94)3&gt;&gt;&gt; math.trunc(-3.14)-3&gt;&gt;&gt; math.trunc(-3.94)-3 全局函数 round 四舍五入： 12345678&gt;&gt;&gt; round(3.4)3&gt;&gt;&gt; round(3.9)4&gt;&gt;&gt; round(-3.4)-3&gt;&gt;&gt; round(-3.9)-4 一些数学常量 pi 圆周率 123&gt;&gt;&gt; import math&gt;&gt;&gt; math.pi3.141592653589793 e 数学常量 e，e即自然常数（自然常数） 有关更多数学计算等需求的，可详阅官方文档：Python 官方文档。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 环境]]></title>
    <url>%2FPython3-%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[–本篇主要讲述 Python的环境– “优雅” “明确” “简单”Python 简要： 以介绍Python的基本安装，和编写Python的一些基本工具的使用和介绍。 Python3 环境搭建 安装请访问官网自行下载Python3的安装包：Python 官网。 注意：请下载Python3.0以上版本，因为我们讲述的是基于Python3的内容!请下载Python3.0以上版本，因为我们讲述的是基于Python3的内容!请下载Python3.0以上版本，因为我们讲述的是基于Python3的内容! 截至本文编写完毕时，当前Python3的最新版本为：3.6.1 安装过程中，可根据需要，自行更改安装位置，但是有一点，请务必勾选一个选项： “Add Python3.6 to PATH” 这个选项是将Python添加至环境变量，便于在命令行中启用Python命令提示符。 附简略安装截图： 校验启用Win操作系统的命令提示符，输入python可校验，安装成功如下图： Python3 IDE工具 基本的Python环境搭建完毕后，接下来便是编写Python的程序。 大多数的编程语言都有着各式各样的编程工具，大多也都是以IDE著称。 那么什么是IDE呢： IDE 集成开发环境（Integrated Development Environment，简称IDE，也称为Integration Design Environment、Integration Debugging Environment） 简言之即为：辅助程序开发人员开发软件的应用软件，在开发工具内部就可以辅助编写源代码文本、并编译打包成为可用的程序，有些甚至可以设计图形接口。 然而由于Python的语言较为简单易学易用，对于大牛来说，可能一个简单的记事本便可搞定基本的Python开发。但是毕竟还是有局限的，所以这里推荐几款在日后我们编写Python的过程中常用或者说比较好用的几款工具，供大家参考和学习。 Sublime Text PyCharm Sublime TextSublime Text是一个插件丰富支持多种语言的编辑器。当前版本最新的叫：Sulime Text3 而且我个人也推荐使用 Sublime Text3 版本，至于 Sublime Text2还是不建议使用的，因为 Sublime Text2 中集成的是 Python 2.7的版本，并不适用我们使用的 Python3。 上面已经给出了官网地址，可自行前往下载并安装使用。 安装完毕后，为了更好的使用 Sublime Text3 编写 Python 程序，有一些插件还是要推荐给大家安装的： Package Control 【Sublime中插件管理工具】 SideBarEnhancements 【Sublime侧边栏扩展工具】 AutoPEP8 【Python编码pep8规范】 SublimeREPL 【可在Sublime中直接运行Python环境】 Anaconda 【自动匹配关键字等实用功能】 更多可用插件可自行查阅相关资料，这里就不一一赘述了。 结语 有关基本Python的环境以及IDE工具介绍就到此为止了，其实工具有很多，重要是的Python代码使用的熟练度和实际项目经验。最后记录相关更多的资料和工具推荐，可详见参考部分。 参考 Python 官网Sublime Text 官网PyCharm 官网ATOM 官网Notepad++ 官网Package Control 官网 Sublime Text的插件管理工具]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 简明纲领]]></title>
    <url>%2FPython3-%E7%AE%80%E6%98%8E%E7%BA%B2%E9%A2%86%2F</url>
    <content type="text"><![CDATA[–本篇为Python3教程的简要纲领– “优雅” “明确” “简单”Python 为了学习Python，摸爬滚打在各种论坛和mooc网教程中，我们通常会看到这么一句话：“人生苦短，我用Python”。其实作为学习Python以及使用这么久的我来说，Python 是很容易入门和掌握的：对于一个深耕技术领域的大牛来说，学习 Python 甚至只需要花费半天的时间就可以；对于一个技术小白，即使连代码从未接触过的人来说，入门Python也仅仅只需不到一周的时间而已。 那么究竟哪门开发语言适合作为初学者的入门语言呢？这里我也不做过多的阐述，毕竟不同的技术出身的大牛会说出各种道理，被推荐为初学者入门语言的也是各种都有。单就我的学习过程和经历来说，是建议从Python学习开始入门的。但不论学什么，重要的是，一旦决定要学习，就要拿出时间、精力认真的学习，端正态度，静下心学下去才能够有收获。 开篇 Python的故事Python的创始人为吉多·范罗苏姆（Guido van Rossum）。1989年的圣诞节期间，吉多·范罗苏姆为了在阿姆斯特丹打发时间，决心开发一个新的脚本解释程序，作为ABC语言的一种继承。之所以选中Python作为程序的名字，是因为他是BBC电视剧——蒙提·派森的飞行马戏团（Monty Python’s Flying Circus）的爱好者。ABC是由吉多参加设计的一种教学语言。就吉多本人看来，ABC这种语言非常优美和强大，是专门为非专业程序员设计的。但是ABC语言并没有成功，究其原因，吉多认为是非开放造成的。吉多决心在Python中避免这一错误，并获取了非常好的效果，完美结合了C和其他一些语言 就这样，Python在吉多手中诞生了。实际上，第一个实现是在Mac机上。可以说，Python是从ABC发展起来，主要受到了Modula-3（另一种相当优美且强大的语言，为小型团体所设计的）的影响。并且结合了Unix shell和C的习惯。目前吉多仍然是Python的主要开发者，决定整个Python语言的发展方向。Python社区经常称呼他是仁慈的独裁者。 Python的版本Python当前有很多版本，目前使用最多的可能是以下两个版本： Python 2.7 Python 3.5 而通常情况下，人们把Python的3.*版本统称为了Python3，相对于Python3.0之前的早期版本，这是一个较大的升级。为了不带入过多的累赘，Python 3.0在设计的时候没有考虑向下兼容。因此在学习过程中，很多人也许会遇到很多的问题，其中就有兼容问题，而有些文献上也有如何让 Python2.7 升到 Python3。 我们这里主要讲述的内容也是 Python3 的内容，而非 Python2.7。尽管当前还有不少项目似乎基于 Python2.7。但是我相信，我们的技术是要不断的向前发展的，只有不断的前进才能拥抱无限的未来，因此在未来Python3也一定是大势所趋。 切记：本文要讲述的是 Python3！ Python3！ Python3！ 纲领 以下是本Python3 学习的纲领，不定期更新： Python3 环境 Python3 数字 Python3 字符串 Python3 列表 Python3 元组 Python3 字典表 Python3 文件（上） Python3 文件（下） Python3 集合 Python3 bool Python3 函数 Python3 类 寄语 以上都是我通过自学，看官网资料，不断积累，遇坑解决，不断摸索、尝试、实践出来的。相信你也可以，一步一步的掌握Python，最终化为自己的知识为你所用。 让我们一起共勉： 持续不断地学习，是更好的成长 —TyouSF]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP简述]]></title>
    <url>%2FHTTP%E7%AE%80%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是互联网上应用最为广泛的一种网络协议。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。 ————维基百科 为什么要了解HTTP呢因为 HTTP 是 web 的核心，也是动态 web 应用的核心。理解 HTTP 是理解现代 web 应用如何工作和如何构建的核心。在今后，无论我们是编写 Web 应用，还是进行接口测试等互联网相关的工作，都必须要掌握的基础。 由于仅仅是做相关的简述，至于更多深层次的理论知识，可以参考结果所提供的相关资料进一步了解。 HTTP – 注解 HTTP 是英文：HyperText Transfer Protocol 的缩写，中文释义：超文本传输协议。 更多的解释也可自行谷歌或者百度。 HTTP – 随处可见 在如今这样一个互联网的世界，其实我们每一个人，只要你上网，其实 HTTP 就存在。只是你并没有注意到它而已。此处，我们举一个典型的例子：使用浏览器访问网站。 当你在浏览器地址栏输入 URL 时，请注意网址的开头，通常就是已 http 开头的。为了更容易理解，我们简单的描述一下我们上网的过程： 一个网站的基本构成是由各式各样的文件组成的——诸如CSS，HTML，Javascript，视频文件，图片文件等等 。这些文件被有组织的存放在互联网上的某一台主机（你可以简单粗暴的理解为电脑）上，这个主机有着自己独特的标签（就好比门牌号码一样贴在这台电脑上）来与互联网上其他的计算机设备进行区分。浏览器就是我们与这台电脑进行交流的媒介。现在，我们在浏览器中输入网址访问到这个网址的内容，就好比：我们告诉浏览器说我们要看一下这个网址的内容，于是浏览器就通过互联网找到了这个网址所对应的主机，然后向主机索要内容（这个过程是请求），主机收到浏览器的请求后，根据浏览器的请求，将存放的诸如CSS，HTML，Javascript，视频文件，图片文件等等组织好后，将这些内容以网页的形式返给浏览器（这个过程是响应），最终浏览器把这些内容呈现给了我们。 那么在这个过程中有一个问题：浏览器拿到网址后，他是如何知道该怎么与服务端主机进行沟通交流的呢？ 就好比人与人之间交流使用的是语言一样，他们之间请求和响应的交流，便是通过“HTTP”。至此，相信大家已经简单的明白了什么是“HTTP”：HTTP 是规定了互联网上机器之间彼此交流和沟通的协议。它遵循一个简单的模式：从客户端（使用浏览器访问的这一方）发送一个请求到服务端，服务端进行响应。 因此有人也简单的定义http为：请求&lt; – &gt;响应 协议。 请求：对应英文–&gt; request 响应：对应英文–&gt; response HTTP – Request http 协议规定了基本请求的内容格式，应当包含： 请求行 –&gt; 对应英文：request line 请求头 –&gt; 对应英文：request header 空行 请求数据 –&gt; 对应英文：body 请求行请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。格式如下：Method Request-URI HTTP-Version CRLF其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。 请求方法，常用的几个典型有： GET：向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。 POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。 PUT：向指定资源位置上传其最新内容。 DELETE：请求服务器删除Request-URI所标识的资源 请求头请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。例如Accept-Language: en。常用的请求报头： Accept-Charset 请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。 Accept-Language 请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。 Accept-Encoding 请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。 空行空行是用于分割请求数据的行，且是必须的。即使第四部分的请求数据是空的，也必须有空行分割。 请求数据请求数据也叫主体，可以添加其他的任意数据。 HTTP – Response http 协议规定了基本响应的内容格式，应当包含： 状态行 消息报头 空行 响应正文 状态行由HTTP协议版本号， 状态码， 状态消息 三部分组成。例如：HTTP/1.1 200 OK 有关状态码——由三位数字组成，第一个数字定义了响应的类别，共分五种类别: 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 常见的诸如：1234200 OK //客户端请求成功403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误 消息报头消息报头，用来说明客户端要使用的一些附加信息。通常有：Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html)，编码类型是UTF-8。 空行用于区分正文部分，且是必须的。表示该空行之后的内容均为正文内容。 响应正文空行后面的html部分为响应正文。也可以是单独的图片或者视频文件等。 结语 以上就是HTTP的基本内容，至于更多更深的东西，可以参考其他文献资料，本文并不做过多的解释和说明。但是 HTTP 是整个互联网的核心，所以我个人认为从 HTTP 开始，去学习 web 开发是一个良好的起点。理解 HTTP 中所包含的 GET，POST，会话（Session），cookies 以及HTTP的“无状态”是什么意思更是必不可少的。只有理解 HTTP 的基础，我们才能了解构建一个 web 应用时，其背后究竟发生了什么以及是如何工作的。其中有些东西诸如会话和Cookie等这里没有提及，在以后的文章中我们再行赘述。 参考资料 HTTP 百度百科HTTP 维基百科HTTP 下午茶]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令汇总]]></title>
    <url>%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统Git 简史 Git是什么，就不多介绍了，相关的资料和度娘的解答相信已经多的数不胜数了。本文主要来讲述我们实际工作中常用的一些基本命令以及使用的汇总。具体和详细的教程以及原理的东西可以参考本文最后给出的资料，个人认为这些资料已经足以阐释很多东西了。废话不多说，进入正文：Git常用命令一览！ 在介绍前，先明确两个基本概念（大牛请直接忽略此处）： 本地仓库在你所使用的电脑上进行创建和管理的仓库，我们称之为本地仓库 远程仓库在GitHub网站上托管的仓库，我们称之为远程仓库 代码内须填参数“&lt; &gt;”在代码中凡是用尖括号“&lt; &gt;”括起来的则是需要我们填写的具体参数，实际使用中，尖括号不用书写 origin 代指远程仓库在本地显示的名称如果没有特殊情况，origin代之远程仓库的名称，这是git默认的名称。 Git 基本配置 配置全局git用户名 1git config --global user.name &quot;yourname&quot; 配置全局git用户邮箱地址 1git config --global user.email yourmail@example.com 查看配置信息 1git config --list Git 本地仓库的初始化 将当前所在的根目录文件夹直接变为git仓库 1git init 在当前的路径下，新建一个我们命名的文件夹，并将其初始化为git仓库 1git init foldername Git 提交管理 提交前，查看当前文件状态 1git status 将某一具体的新增或有修改的代码文件添加至暂存区等待提交 1git add filename 将某一具体的已添加至暂存区的文件从暂存区移除 1git reset HEAD filename 批量添加所有新增或有变更的文件至暂存区等待提交 1git add . 将暂存区的文件提交至当前分支，并添加本次提交的注释 1git commit -m &quot;comments for your commit&quot; 撤销刚才的提交并重新编辑注释后再次提交 1git commit --amend 跳过添加暂存区直接进行提交 1git commit -a -m &quot;comments for your commit&quot; 查看提交历史 1git log Git 文件管理 从工作目录中手工删除文件 12rm filename # 移除文件git rm filename # 在暂存区记录此次的移除操作 移动并重命名文件 1git mv file_from file_to Git 本地分支管理 注意事项： 在使用本地分支管理之前，请确保你所创建的本地仓库并不是空的，且有过提交历史，否则可能无法顺利创建分支。 创建新的分支 1git branch &lt;new_branch&gt; 切换到某个分支 1git checkout &lt;branch&gt; 创建新的分支并切换到新建的分支 1git checkout -b &lt;new_branch&gt; 基于现有分支创建新分支并切换过去 1git checkout -b &lt;new_branch&gt; &lt;branch&gt; 查看当前所有分支 1git branch 将某一分支合并到当前分支 1git merge &lt;branch&gt; 查看各个分支最后提交信息 1git branch -v 查看已经被合并到当前分支的分支 1git branch --merged 查看尚未被合并到当前分支的分支 1git branch --no-merged 安全删除分支（如果该分支并未被合并，删除该分支会提示错误，因为那样做会丢失数据） 1git branch -d &lt;branch&gt; 强制删除某个分支（未被合并的分支被删除的时候需要强制） 1git branch -D &lt;branch&gt; 远程仓库管理 给本地仓库添加一个远程仓库 1git remote add &lt;shortname&gt; &lt;url&gt; 修改远程仓库地址 1git remote set-url &lt;shortname&gt; &lt;new_url&gt; 克隆远程仓库到本地新仓库 1git clone &lt;repository_url&gt; 查看当前的远程仓库 1git remote 查看远程仓库状态 1git remote show origin 删除本地添加的远程仓库 1git remote rm &lt;shortname&gt; 重命名本地的远程仓库名 1git remote rename &lt;shortname&gt; &lt;new_shortname&gt; 远程分支管理 首次提交本地分支至远程分支（如无远程主分支则创建，用于初始化远程仓库） 1git push -u origin &lt;branch&gt; 非首次提交至远程分支（默认自动提交至当前本地分支所对应的远程分支） 1git push 抓取远程仓库所有分支更新并合并到本地 1git pull 抓取远程仓库所有分支更新并合并到本地，不要快进合并 1git pull --no-ff 抓取远程仓库更新 1git fetch origin 将远程分支合并到本地当前分支 1git merge (远程仓库名)/(远程分支名) 跟踪某个远程分支创建相应的本地分支 1git checkout --track &lt;origin&gt;/&lt;branch&gt; 删除远程分支，origin是远程仓库名 1git push origin :&lt;branch&gt; 本地分支与远程分支关联 绑定远程和本地分支1git branch --set-upstream &lt;local_branch&gt; &lt;origin&gt;/&lt;origin_branch&gt; SSH公钥 生成 SSH 公钥1ssh-keygen 结语 通过上述的一些命令，我们日常git的使用基本没有什么问题了。但是实际使用过程中可能会遇到诸多的问题，顿时很是疑惑，也不知该如何解决。相信在您使用上一段时间后，肯定会遇到的。这个时候我们要多查找一些官方文档或者资料，多学习多看多实践，相信一定可以得到解决。如果有时间，建议了解一下Git的一些底层和原理性的东西，更能加深我们对Git的理解。 参考资料 Pro Git 简体中文版Git 简易指南Git 实操学习站点]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Appium Demo 下篇]]></title>
    <url>%2FAppium-Demo-%E4%B8%8B%E7%AF%87%2F</url>
    <content type="text"><![CDATA[一个Appium的Demo之旅 TyouSF 本文我们将使用Python语言编写第一个基于Appium的自动化测试脚本。 脚本实际运行效果：在Android模拟器中，自行调用计算器，完成一个简单的数学计算：1+1 编写前必须要声明的注意事项： Appium当前版本为：1.4.16.1由于版本原因，当前该版本最高支持到Android M，及Android 6.0，对应Android API 23 安卓模拟器的创建基于上一条Appium的原因，对7.0以上的Android版本支持不太友好，存在Bug，如果您坚持使用基于7.0以上创建的安卓模拟器，运行过程中可能会遇到各种问题，不建议采用。建议创建一个基于Android 6.0 版本的模拟器，如果您还不知道怎么创建，可详细查阅Appium Demo 上篇 启动Appium运行Appium客户端，并启动Appium服务。启动图如下： 启动Android AVD打开Android Studio启动创建好的安卓模拟器即可 编写Python脚本1234567891011121314151617181920from appium import webdriverdesired_caps = &#123;&#125;desired_caps['platformName'] = 'Android'desired_caps['platformVersion'] = '4.4.2'desired_caps['deviceName'] = 'Android Emulator'desired_caps['appPackage'] = 'com.android.calculator2'desired_caps['appActivity'] = '.Calculator'driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps)driver.find_element_by_name("1").click()driver.find_element_by_name("+").click()driver.find_element_by_name("1").click()driver.find_element_by_name("=").click()driver.quit() 执行脚本假设您编写的脚本名称为：demo.py1python demo.py 如果没有异常，运行脚本后，您便可以在Android AVD中看到整个执行过程。就像这样：↓]]></content>
      <categories>
        <category>Appium</category>
      </categories>
      <tags>
        <tag>appium</tag>
        <tag>测试</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Appium Demo 上篇]]></title>
    <url>%2FAppium-Demo-%E4%B8%8A%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Pytho + Android AVD + Appium构建我们的第一个DEMO TyouSF 本篇内容要旨： 主要讲述为了完成我们第一个Demo，所需要完成的基本准备工作。 声明：本Demo主要基于Python语言进行编写，因此，准备工作中的语言库也将围绕Python进行展开。如果您使用的是其他的语言，那么非常抱歉，本文可能并不适合您，建议您通过官网进行相关资料的查询与阅读。 接下来，看看我们都需要哪些吧： Python Python第三方库–Appium Python Client Android AVD（简称安卓模拟器） Python 这是我们基于Python语言编写的基本也是硬性要求了，就不多解释了。另：由于本Demo的编写是基于Pyhon3，安装时请务必选择Python3以上的版本。 有关Python的安装，详细可访问Python 官网进行下载。 友情提示：Win操作系统下，为了获得更好的Python支持，在安装Python时，请务必注意一个选项： Add python to Path 该选项即是将python添加至系统的环境变量中，这样在安装以后，您便可以在命令提示符中直接使用python相关的命令而无须再进行环境变量的配置。如果您安装时没在意，没关系，卸载Python后重新安装即可（重新安装时记得选上噢！）。 Appium Python Client仅仅是安装Python的语言环境是不够的，我们还要安装Appium的支持库。安装很简单，但是在安装前，不得不提的是：由于直接安装，可能会导致您当前Python的语言环境不够纯粹。通常情况下，在使用Python的过程中，为了满足不同的项目需求，需要各种第三方库的支持，为了方便管理也为了保持本身Python语言环境的纯粹，会使用沙盒来进行管理和安装。 沙盒：所谓沙盒环境，是使用Python进行创建的一个基于纯粹Python语言环境下的虚拟环境。在Python中，通常叫做“venv”。安装第三方库便可以在“venv”中进行安装，这样既不会影响我们主题的Python语言环境，也可以为不同的项目创建不同的“venv”环境。 安装Appium Python Client———— 在命令提示符下，使用如下命令创建“venv”： 1python -m venv venv 激活虚拟环境 1venv\Scripts\activate.bat 安装Appium Python Client 1pip install Appium-Python-Client 上述总执行过程类似如下图所示： Android AVD（简称安卓模拟器）由于Demo编写后，需要借助安卓模拟器来展示效果，因此需要安装一下Android AVD。如果您看过上一篇文章Appium 基础的话，相信基本环境已经搭建完毕了。而我们Android AVD的安装便需要用到Android Studio。 启动Android Studio后，参照下图所示的顺序以及说明进行安装即可。 结语 至此，Demo上篇的基本准备工作已经完毕。接下来，让我们一起看看一个Demo是如何编写的吧。开始前，您可以参照下列资料进行一些自行学习和了解： Appium Python ClientPython3 教程]]></content>
      <categories>
        <category>Appium</category>
      </categories>
      <tags>
        <tag>appium</tag>
        <tag>测试</tag>
        <tag>android avd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Appium 基础]]></title>
    <url>%2FAppium%20%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Appium是一个自动化测试开源工具，支持 iOS 平台和 Android 平台上的原生应用，web 应用和混合应用。 Appium TyouSF Appium 介绍 Appium 是一个自动化测试开源工具，支持 iOS 平台和 Android 平台上的原生应用，web 应用和混合应用。 “移动原生应用”是指那些用iOS或者Android SDK写的原生应用。 “移动web应用”是指使用移动浏览器访问的应用。 “混合应用”是指原生代码内嵌H5的形式。比如应用内直接打开网页等。 除此之外，Appium 是一个跨平台的工具：它允许测试人员在不同的平台（iOS，Android）使用同一套API来写自动化测试脚本，这样大大增加了测试套件间代码的复用性。 Appium理念为了满足移动自动化需求，Appium 遵循着一种哲学，主要有以下4条： 你无需为了自动化，而重新编译或者修改你的应用。 你不必局限于某种语言或者框架来写和运行测试脚本。 一个移动自动化的框架不应该在接口上重复造轮子。（移动自动化的接口应该统一） 无论是精神上，还是名义上，都必须开源。 Appium框架Appium真正的工作引擎其实是苹果和谷歌官方提供的测试框架： iOS: 苹果的UIAutomation Android: Google的UiAutomator 将这些框架封装成一套API–WebDriver（也就是 “Selenium WebDriver”） 指定了客户端到服务端的协议。使用这种客户端-服务端的架构，我们可以使用任何语言来编写客户端，向服务端发送恰当的 HTTP 请求。 事实上 WebDriver 已经成为 web 浏览器自动化的标准，也成了 W3C 的标准——W3C Working Draft 概念注解C/S 架构Appium的核心是一个web服务器，它提供了一套接口。它收到客户端的连接，监听到命令，然后在移动设备上按照这些命令执行，然后将执行结果放在HTTP响应中返回给客户端。 SessionSession我们可以理解为一个上下文链接的对象，我们每次执行测试时，客户端初始化一个seesion（会话）来与服务端交互，之后，我们每一次的运行命令，都将通过这个Session进行后续命令的传达（下发）。 Desired CapabilitiesDesired capabilities是一些键值对的集合（就好比Python中的字典表），客户端将这些键值对发给服务端，告诉服务端我们想要怎么测试。其中所涉及的一些数值，比如： platformName: iOS：则是告诉Appium服务端，我们测试的应用是ios 等等诸如此类的，可以在后续我们脚本编写中进行更为详细的了解。 Appium Server是用Node.js编写的一个服务器。也是我们所编写测试脚本命令所要发送给的对象，经由Appium Server再向测试应用的终端发送执行命令。我们可以用源码编译或者从NPM直接安装。 Appium ClientAppium Client即我们使用的客户端，也就是我们编写脚本的支持。涉及Java, Ruby, Python, PHP, JavaScript和C#等实现了Appium对WebDriver协议的扩展的语言。我们使用过程中选择一个适合您当前所掌握的语言即可。 Appium 安装 以下将介绍Appium如何安装，以及相关环境的配置。如果其中有哪些您已经安装过或者配置过，您可自行忽略。另：本文所讲述的安装和配置教程，均是基于Win操作系统，如果您使用的是Mac或其他平台，可查询相关官方文档。 安装清单： JAVA JDK Android Studio Node.js Appium JAVA JDKAndroid是由Java语言开发的，所以想开发Android应用首先需要Java环境。 JAVA JDK 下载地址：Java JDK 安装下载后双击安装文件，进行安装即可，安装时可自行更改安装位置。此处假设您安装时所选路径为：D:\Java。 配置接下来，进行环境变量的设置： “我的电脑”右键菜单—&gt;属性—&gt;高级—&gt;环境变量 添加JAVA_HOME的变量（变量值根据当前你所安装的JDK目录下的实际版本进行填写） 12变量名：JAVA_HOME 变量值：D:\Java\jdk1.8.0_121 添加CLASS_PATH的变量 12变量名：CLASS_PATH变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 在Path变量中添加如下两个变量值（非Win10操作系统直接添加：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;）： %JAVA_HOME%\bin %JAVA_HOME%\jre\bin 截图参考：↓ 校验设置后，在Win下的命令提示符中验证是否配置成功： 打开Win的命令提示符 输入java -version 展示如下图所示结果，即证明JAVA JDK配置成功 Android Studio有看过其他文章和资料的，相信一定看到过很多需要您安装的，诸如“Android SDK”，“Android ADT”，“Android SDK Platform-Tools”等等很多关于Android环境的安装包。但是其实完全是没有必要的。因为现在最新的Android Studio已经集成上述各种的安装包，无需一一去找和一一安装，我们只需要安装一个最新最全的Android Studio即可。 Android Studio Android Studio是一个为Android平台开发程序的集成开发环境。 维基百科zh.wikipedia.org/wiki/Android_Studio 安装访问Android Studio官网进行下载（https://developer.android.com/studio/index.html?hl=zh-cn） 同样，双击安装包进行安装即可，至于安装路径您可自行更改，这点并不影响。 配置Adb参照下图，添加ANDROID HOME的环境变量，以及对应Path下的变量值： 校验adb在Win命令提示符下，输入adb，如果出现下图所示结果，即证明adb配置成功： Node.js安装访问Nodejs官网nodejs，按照下图所示，点击下载即可。下载完毕后，双击安装包进行安装，安装过程中默认各选项，一直下一步即可。 校验在Win命令提示符下，输入node -v，如果出现下图所示结果，即证明node环境OK： Appium有关Appium的安装，官方首页给出的是使用Node.js进行的安装，但是并不建议使用官方的安装命令，因为在安装过程中，会遇到下载异常问题，而且文件也众多，下载也缓慢。建议点击主页的下载按钮来直接下载。下载后，是一个zip包，我们解压后，里面会有两个文件： appium-installer.exe update.bat 安装我们只需要双击appium-installer.exe，进行安装即可。同样的，至于安装在哪里，这完全随您喜欢。 附上安装截图：↓ 校验通过Appium客户端校验启动Appium，正常启动后，则展示如下： 但是这并不能证明我们的Appium整体环境是否已经搭建成功。接下来，我们在启动Appium后，选择执行Appium按钮之后，如果无异常，应当是如下图所示这样： 通过appium-doctor命令校验如果您在看本篇教程之前，有看过他人写的一些文章的话，您可能会接触到这样一条校验appium环境是否搭建成功的命令：1appium-doctor 关于这条命令，并不是所有人都可以直接执行的。首先如果是通过NPM的命令来安装appium的话，笔者并不是很清楚是否可以执行。但是假设您是跟着本教程通过Win下的安装包完成安装的，那么恭喜您：这条命令您并不能直接在Win的命令提示符下执行。执行的时候Win会提示我们这并不是内部或外部命令。原因： 很简单，安装包完成安装后，并没有进行相关环境变量的配置 那么接下来，我们一起看看如何让appium-doctor成功运行： 寻找“appium-doctor”进入到您安装Appium的目中 –》 会看到有一个文件夹名称为：“node_modules” –》 进入“node_modules”后，会看到有个文件夹名称为：“.bin” –》 进入到“.bin”目录中，您便会发现有一个“appium-doctor.cmd”的文件，恭喜您已经找到了！ 配置“appium-doctor”到环境变量”将步骤1中“appium-doctor.cmd”的目录进行复制，就像这样一个地址：E:\Appium\node_modules.bin（具体按照您实际安装的目录进行修改！）。之后进入系统环境变量的Path中进行添加，如图： Win命令提示符下的校验配置后，在Win命令提示符中输入appium-doctor，如果出现类似下图结果：则证明环境成功搭建完毕。（有任何不成功的，都将会标红并提示出具体还缺少什么环境） 结语 相信只要按照本文所述的顺序，进行基本的环境搭建，都应当不会有太大问题。至此，恭喜正在搭建此环境的你，已经成功开启了Appium之旅。接下来，让我们一起看看如何利用‘Python’语言完成我们第一个自动化测试安卓App的Demo脚本吧！ 相关学习资料如下（坚持学习，您将能够获得更多的收获）： Python3 中文教程Appium 中文文档Android 调试桥]]></content>
      <categories>
        <category>Appium</category>
      </categories>
      <tags>
        <tag>appium</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客的SEO]]></title>
    <url>%2FHexo%E5%8D%9A%E5%AE%A2%E7%9A%84SEO%2F</url>
    <content type="text"><![CDATA[好不容易搭建起了第一个属于自己的个人博客站点，然后使用谷歌以及百度搜索自己的博客网站时，突然发现：What?居然搜索不到！！！顿时不禁黯然神伤。。。。。。这个时候，就意味着我们需要对自己的博客，进行SEO！–TyouSF 搜索引擎优化（英语：search engine optimization，缩写为SEO），是一种通过了解搜索引擎的运作规则来调整网站，以及提高目的网站在有关搜索引擎内排名的方式。由于不少研究发现，搜索引擎的用户往往只会留意搜索结果最前面的几个条目，所以不少网站都希望通过各种形式来影响搜索引擎的排序，让自己的网站可以有优秀的搜索排名。当中尤以各种依靠广告维生的网站为甚。 搜索引擎优化维基百科 为什么要SEO 当我们拥有自己的博客站点后，我们当然希望我们自己的博客可以在各种的搜索引擎中能够被搜索到。这样，就会有更多的人知道和了解我们，从而让自己小有名气！可是此时，当我们搭建完毕我们的博客站点后，此时谷歌也好百度也好都是搜索不到的！这是为什么呢？因为我们的站点没有被搜索引擎收录！那么如何解决想必你也知道方法了：那就是让搜索引擎收录我们的站点。如何收录呢？接下来就动起手来，让我们的站点被搜索引擎收录吧！ 注： 本文主要以Google搜索为主进行讲解，有关百度的收录，基本与Google操作一致，各位看官可自行动手实现一下，也当是检测自己的掌握情况！ 本文的优化结果与主题有一定关系，高度适用于使用 NexT 主题进行搭建的 Hexo 博客，其他主题可进行变通 为了描述方便，在以下说明中，将位于站点根目录下，主要包含Hexo本身的配置文件称之为：“站点配置文件”，将位于主题目录下的配置文件称之为：“主题配置文件” 准备工作 安装 sitemap为了能够让我们的站点被收录，我们需要为我们的hexo博客安装相关支持的包。这两个包分别为： hexo-generator-sitemap 【该包用于支持Google搜索引擎】 hexo-generator-baidu-sitemap 【该包用于支持百度搜索引擎】 对应的安装命令如下：12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 了解 sitemapsitemap：中文译为“站点地图” 什么是站点地图？ 站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知 Google 和其他搜索引擎。Googlebot 等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 此外，站点地图能够提供与其中所列网页相关的宝贵元数据：元数据是网页的相关信息，例如此网页的上次更新时间、更改频率及其重要性（与相应网站中的其他网址相较而言）。 您可以使用站点地图向 Google 提供您网页上特定类型内容（包括视频和图片内容）的元数据。例如，您可以向 Google 提供有关视频和图片内容的信息： 站点地图视频条目可以指定视频的时长、类别和年龄适宜性分级。站点地图图片条目中可包含图片主题、类型和许可。 修改站点配置文件 _config.yml 添加如下的配置（注意每行的空格） 12345# sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 找到原URL的部分，并修改为自己的博客网址，如下： 123# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.github.io 修改文章链接，在上述步骤2的url下方，找到关键字 permalink，并修改为如下形式： 1permalink: :title/ 在博客根目录中的 source 文件夹下，添加蜘蛛协议 “robots.txt” 的文件，内容如下： 12345678910111213141516User-agent: *Allow: /Allow: /categories/Allow: /tags/Allow: /archives/Allow: /about/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://yoursite.github.io/sitemap.xmlSitemap: http://yoursite.github.io/baidusitemap.xml 基于 NexT 主题的首页 title 优化如果恰巧你也使用的是NexT主题，那么可以参照如下的方式进行首页 title 优化。这并非必要，可因个人喜好而自行决定是否修改。 对应修改文件的路径：your-hexo-site/themes/next/layout 下的 index.swig 文件。 找到上述 index.swig 文件中如下的代码片段：1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 然后修改其为如下代码：1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 如果做了SEO关键字的设定，也期望在首页 title 中显示的话，也可修改为如下的代码：1&#123;% block title %&#125; &#123;&#123; theme.keywords &#125;&#125; - &#123;&#123; config.title &#125;&#125;&#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 基于 NexT 主题添加 nofollow 标签注：此项也并非必须要修改，非NexT主题也可忽略！！！ nofollow标签是由谷歌领头创新的一个“反垃圾链接”的标签，并被百度、yahoo等各大搜索引擎广泛支持，引用nofollow标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重。 rel这个属性它有许多的属性值，比如next、previous,、chapter、 section等等，比较常见的是 rel=&#39;external nofollow&#39; 与 rel=&#39;nofollow&#39; 两种参数的应用！ rel=&#39;nofollow&#39; 属性是谷歌为了应对垃圾链接而引入的一个属性值，被各大搜索引擎引用！rel=&#39;external nofollow&#39; 只是更相对于 rel=&#39;nofollow&#39; 参数更加规范一些而已！ rel=&#39;external nofollow&#39; 与 rel=&#39;nofollow&#39; 其功能的中文译文为“不要读取”或“外部链接不要读取”的意思！ 第一步：修改 footer.swig 文件 找到位于：your-hexo-site/themes/next/layout/_partials/footer.swig 路径下的 footer.swig文件，打开后，找到如下的代码片段：1&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125; 将其修改为：1&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; href=&quot;http://hexo.io&quot; rel=&quot;external nofollow&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125; 接下来，继续找到如下代码片段：1&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt; 将其修改为：1&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot; rel=&quot;external nofollow&quot;&gt; 第二步：修改 sidebar.swig 文件 找到位于：your-hexo-site/themes/next/layout/_macro/sidebar.swig 路径下的 sidebar.swig文件，打开后，找到如下的代码片段：1&lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; target=&quot;_blank&quot; title=&quot;&#123;&#123; name &#125;&#125;&quot;&gt; 修改为：1&lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; target=&quot;_blank&quot; title=&quot;&#123;&#123; name &#125;&#125;&quot; rel=&quot;external nofollow&quot;&gt; 接下来，继续找到如下代码片段：1&lt;a href=&quot;https://creativecommons.org/&#123;% if theme.creative_commons === &apos;zero&apos; %&#125;publicdomain/zero/1.0&#123;% else %&#125;licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&#123;% endif %&#125;/&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot;&gt; 将其修改为：1&lt;a href=&quot;https://creativecommons.org/&#123;% if theme.creative_commons === &apos;zero&apos; %&#125;publicdomain/zero/1.0&#123;% else %&#125;licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&#123;% endif %&#125;/&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt; Google 收录 登录 Google Search Console Google 网站站长 添加我们的博客站点 进行验证：验证方式有多种，此处我们以“HTML标记”为例：选择HTML标记后，会有一段代码，我们将代码中的content所对应的值进行复制，找到我们的主题配置文件，找到关键字google_site_verification之后，将我们复制的值粘贴至此处（并取消注释）即可。 重新生成站点（完成上述所有的设定后）使用hexo generate重新生成我们的站点，为了保证有效生成，可在每次生成前，先进行清理：hexo clean。这个时候，我们便可以在Hexo的站点“public”文件夹中发现：sitemap.xml 与 baidusitemap.xml 的两个文件已经生成。 部署新的站点将我们最新配置后并生成的站点（操作4所生成的站点），重新部署至 GitHubPages 上。 部署后，此时在Goole中进行验证（建议部署后等待几十秒，以便部署生效后，再进行验证） 验证成功后，在Google Search Console平台添加我们的站点地图 添加Google抓取：我们以抓取首页为例，直接点击抓取按钮即可看到抓取结果 将抓取通过的地址，进行请求编入索引（我们以博客首页加入抓取索引为例） 编入索引后，打开Google进行搜索（以博主的博客为例，搜索“tyousf”），确认结果： 结语 由于也是各种探索和尝试中进行的，难免有所纰漏，如果有问题，欢迎大家在下方留言处多多指正。 在尝试过程中，博主也是找了很多的资料，其中各种描述，看的也是云里雾绕！经过自己亲自实践后，整编成本文！其中已经做了很多的修正。不过当然要感谢每一个我参考过资料的作者，没有他们的贡献，我也不可能这么快的实现SEO。 总结起来我们必须要做如下的事情进行基本的SEO： 安装 Sitemap 支持的包 配置 sitemap 的代码 修改 URL 为站点地址 优化文章链接 permalink 添加蜘蛛协议 robots.txt 搜索引擎站长网站进行网站收录 验证站点 添加站点地图 添加编入索引 接下来，让我们自己动手，添加百度收录吧！！！附上百度站长平台传送门：百度站长平台 参考资源 sitemapSEO]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建中的问题整合]]></title>
    <url>%2FHexo%E6%90%AD%E5%BB%BA%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[前序 本文旨在对于Hexo搭建过程中，遇到的一些问题的整理，希望也能帮助正在阅读的你，解决一些疑惑 关于npm命令npm命令安装第三方插件时的执行路径使用过Hexo后，我们会发现，前端页面显示通常仅仅支持了简易的markdown语法，如果要扩展在网页中呈现更高级的markdown语法特性，我们便要去寻找扩展的插件。 幸运的是，Hexo官网已经为我们提供了官网的一些可能会用到的插件，我们需要按照官网的链接去寻找，并按照对应的安装方式进行安装即可，这里附上Hexo官方插件查询地址：Hexo 插件 注意:我们在安装任何第三方的插件库来扩展我们的站点时，请务必在我们的站点根目录下执行相应的安装命令。假设——我们的站点，安装在D盘，名为myblog的文件夹下，我们想要让我们的站点支持页面的脚注功能，对应的插件名为hexo-footnotes,首先启动GitBash，然后我们应当这么执行：123456yourpcname@DESKTOP-OLULDAI MINGW64 ~$ cd d:yourpcname@DESKTOP-OLULDAI MINGW64 /d$ cd myblogyourpcname@DESKTOP-OLULDAI MINGW64 /d/myblog$ npm install hexo-footnotes --save 如果你发现安装的插件不起作用，一定要确认是否是在站点目录下执行的安装命令。 学会利用hexo clean的命令如果你发现，你新修改的主题以及样式，没有展示为最新的，可以使用该命令清除数据之后，再次启动或者重新生成站点后再提交至Git。 使用hexo deploy自动部署遇到问题通常使用自带的部署命令可能会存在一些问题，官方也有提及。所以遇到问题之后，建议回归到Git的本质，来使用原生的Git命令来提交。那么问题来了： 我们该把什么作为我们的博客文件提交至Git呢？ 我们该怎么管理我们本地仓库与远程Git仓库呢？ 第一个问题：其实真正需要我们提交至Git，作为我们博客的文件，是我们hexo搭建的站点跟目录下的public文件夹内的所有文件。每当我们要发布最新的博文时，我们就先使用hexo generate来生成public文件夹。第二个问题：建议通过克隆我们远程的站点仓库，来创建我们的本地站点仓库。假设我们在d盘下执行：1234yourpcname@DESKTOP-OLULDAI MINGW64 ~$ cd d:yourpcname@DESKTOP-OLULDAI MINGW64 /d$ git clone git@github.**.... 执行后，我们本地D盘就会有一个Git仓库，里面存放着我们的远程站点内容。此时我们可以将最新的public文件夹内的所有文件拷贝到这里之后，使用如下命令来完成部署：12345678yourpcname@DESKTOP-OLULDAI MINGW64 /d$ cd yourname.github.ioyourpcname@DESKTOP-OLULDAI MINGW64 /d/yourename.github.io$ git add .yourpcname@DESKTOP-OLULDAI MINGW64 /d/yourename.github.io$ git commit -m &apos;***&apos;yourpcname@DESKTOP-OLULDAI MINGW64 /d/yourename.github.io$ git push 关于Hexo的一些提醒事项：Hexo所搭建的博客是静态的，同时GitHubPages虽然是我们的站点博客，但同时也是公开的，因此： 任何人都可以看到我们博客的仓库原文件，因此，切勿存放以及暴露个人隐私数据； 任何人都可以看到我们博客的仓库原文件，因此，切勿存放以及暴露个人隐私数据； 任何人都可以看到我们博客的仓库原文件，因此，切勿存放以及暴露个人隐私数据；]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages + Hexo & NexT 快速构建静态Blog]]></title>
    <url>%2FGitHub-Pages-Hexo-NexT-%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81Blog%2F</url>
    <content type="text"><![CDATA[写在本博客搭建完毕之初 本文旨在快速让各位读者拥有属于自己的静态博客，相信纯属小白不懂代码的读者，只要按照如下所述的步骤进行操作，瞬间即可拥有自己的个人免费静态博客。 所涉及到的工具有： Git Node.js Hexo NexT 从GitHub开始，拥有一个不完美的站点有关GitHub尚不清楚的小伙伴，可自行百度，进行更详细的了解。这里只进行简单的介绍和说明： GitHub是一个通过Git进行版本控制的软件源代码托管服务，由GitHub公司（曾称Logical Awesome）的开发者Chris Wanstrath、PJ Hyett和Tom Preston-Werner使用Ruby on Rails编写而成。 维基百科zh.wikipedia.org/wiki/GitHub 注册GitHub访问GitHub主页，进行基本的GitHub账户注册，此时，面前的你可能会面临一个问题————由于国内的“防火长城”，GitHub网站有可能无法访问。有过科学上网经验的小伙伴一定不陌生，使用我们的科学上网姿势，即可访问。如果面前的你对科学上网尚且一无所知，那也没有关系，自行百度“科学上网”，总能找到一款适合您的解决方案。如果你没有更好的选择，那么我个人推荐使用Shadowsocks，打开网站后，切换为中文，按照官网的教程，相信您马上就可以get到科学上网的姿势。 解决墙的问题后，访问GitHub，并完成注册即可。 注册页面见：↓ 快速拥有一个不完美的站点完成注册后，按照下图的顺序，完成各个步骤的操作： 进入到我们的个人资料 进入我们的git仓库 新建一个远程Git代码仓库 新建我们的博客托管仓库此处，我们假设你注册时的github的用户名为：yourname，创建一个yourname.github.io的仓库，具体可参照下图。 创建完毕后，恭喜您，您已经拥有了个人站点，虽然还不完美。 通过在浏览器中输入我们操作4中创建的仓库名，即可访问到。举个例子——我们按照操作4中假设的名称创建的话，那么您访问的地址应当是：https://yourname.github.io/。各位读者只需要把yourname.github.io换成您创建仓库时所填写的对应名称即可。 搭建Hexo，让我们的站点更为完美关于Hexo的搭建，您可以参考Hexo官网，点此→Hexo，阅读更为详细的文档说明。如果您使用的是mac，那么请对照Hexo的官方文档进行搭建，本文主要介绍Windows操作系统上的搭建和使用（请各位读者谅解）。 认识HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo什么是Hexo 环境搭建安装Git看过前面的教程后，大家已经使用过Git，等等，那不是一个网页吗，怎么还需要安装Git了？没错，我们是要安装，原因是，您所访问的是Git的远程仓库托管，但是本地化的Git才是用于我们代码管理的本质，因此我们需要安装一个本地的Git管理工具。 可以访问Git工具的官网Git，和前面所介绍的一样，可能会遇到墙的问题，此处不再细说，可参照前文所写。 登录后，官网点击下载即可，详细如下图：下载完毕后，双击安装包进行安装，安装过程中默认各选项，一直下一步即可。 安装Node.js访问Nodejs官网nodejs，按照下图所示，点击下载即可。下载完毕后，双击安装包进行安装，安装过程中默认各选项，一直下一步即可。 安装Hexo安装完Git后，在桌面空白地方，点击鼠标右键，可发现菜单栏中存在名为Git Bash Here的可选项，我们选择它即可开启我们的git命令行操作界面 选择Git Bash Here 启动Git Bash Here后的界面 安装Hexo在打开的Git Bash界面内，我们输入如下的命令即可完成Hexo的安装 npm install -g hexo-cli Hexo &amp; NexT 让我们的博客更完美使用Hexo与NexT通常我们会有如下的操作来初始化我们的hexo博客，请打开我们的GitBash，在命令行中输入下列的命令： cd d:用于切换到指定盘符下，随您喜欢（建议找一个您方便查看的盘符下） hexo init yourfilenameyourfilename是您指定的文件夹名称（建议英文名，如果您没有好的名字，可以试试“myblog”） cd yourfilename进入到我们hexo初始化的文件夹目录下 npm install完成安装 git clone https://github.com/iissnan/hexo-theme-next themes/next下载NexT主题 打开位于站点(yourfilename)根目录下_config.yml文件，找到 theme 字段，并将其值更改为 next 回到GitBash界面，使用hexo server启动我们的站点 启动后，打开浏览器，输入：localhost:4000即可看到我们本地启动的博客 到此为止，恭喜您，已经成功的让自己的博客运行起来了。 部署本地的博客站点到GitHub上配置Git 安装hexo-deployer-git,在GitBash中使用如下命令npm install hexo-deployer-git --save 在站点根目录下的_config.yml中修改配置deploy: type: git repo: &lt;repository url&gt; branch: master message: 获取repository url,可参照下图： hexo deploy执行后，按照提示输入git账户与密码后，即可完成部署 此时访问您的站点：https://yourname.github.io/即可看您搭建好的博客 感谢您的坚持，同时恭喜您，您的博客已经搭建好了 后续本博客搭建也好，还是后续的文章编写等，都涉及到命令行，因此需要各位读者在后续的时间里，对Hexo的命令，以及Git的命令都要有所了解，同时还要对Markdown的语法有一定的了解，能够编写最基本的Markdown语法的文章。相关学习资料如下（坚持学习，您将能够获得更多的收获）： Git 简体中文版Hexo 文档Markdown 入门参考NexT 使用指南]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>github pages</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
</search>